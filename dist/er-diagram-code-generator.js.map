{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/ansi-regex/index.js","webpack:///./node_modules/ansi-styles/index.js","webpack:///./node_modules/camelcase/index.js","webpack:///./node_modules/cliui/index.js","webpack:///./node_modules/color-convert/conversions.js","webpack:///./node_modules/color-convert/index.js","webpack:///./node_modules/color-convert/route.js","webpack:///./node_modules/color-name/index.js","webpack:///./node_modules/decamelize/index.js","webpack:///./node_modules/emoji-regex/index.js","webpack:///./node_modules/find-up/index.js","webpack:///./node_modules/get-caller-file/index.js","webpack:///./node_modules/is-fullwidth-code-point/index.js","webpack:///./node_modules/locate-path/index.js","webpack:///./node_modules/p-limit/index.js","webpack:///./node_modules/p-locate/index.js","webpack:///./node_modules/p-try/index.js","webpack:///./node_modules/path-exists/index.js","webpack:///./node_modules/pluralize/pluralize.js","webpack:///./node_modules/require-directory/index.js","webpack:///./node_modules/require-main-filename sync","webpack:///./node_modules/require-main-filename/index.js","webpack:///./node_modules/set-blocking/index.js","webpack:///./node_modules/string-width/index.js","webpack:///./node_modules/strip-ansi/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/which-module/index.js","webpack:///./node_modules/wrap-ansi/index.js","webpack:///./node_modules/y18n/index.js","webpack:///./node_modules/yargs sync","webpack:///./node_modules/yargs-parser sync","webpack:///./node_modules/yargs-parser/index.js","webpack:///./node_modules/yargs-parser/lib/tokenize-arg-string.js","webpack:///./node_modules/yargs/build/lib sync","webpack:///./node_modules/yargs/build/lib/apply-extends.js","webpack:///./node_modules/yargs/build/lib/argsert.js","webpack:///./node_modules/yargs/build/lib/command.js","webpack:///./node_modules/yargs/build/lib/common-types.js","webpack:///./node_modules/yargs/build/lib/completion-templates.js","webpack:///./node_modules/yargs/build/lib/completion.js","webpack:///./node_modules/yargs/build/lib/is-promise.js","webpack:///./node_modules/yargs/build/lib/levenshtein.js","webpack:///./node_modules/yargs/build/lib/middleware.js","webpack:///./node_modules/yargs/build/lib/obj-filter.js","webpack:///./node_modules/yargs/build/lib/parse-command.js","webpack:///./node_modules/yargs/build/lib/process-argv.js","webpack:///./node_modules/yargs/build/lib/usage.js","webpack:///./node_modules/yargs/build/lib/validation.js","webpack:///./node_modules/yargs/build/lib/yargs.js","webpack:///./node_modules/yargs/build/lib/yerror.js","webpack:///./node_modules/yargs/index.js","webpack:///./node_modules/yargs/yargs.js","webpack:///./src/dsl/generator/common/case-format/AbstractCamelCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/AbstractUnderscoreCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/CapitalizedUnderscoreCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/LowerCamelCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/LowerUnderscoreCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/StandardCaseFormats.ts","webpack:///./src/dsl/generator/common/case-format/UpperCamelCaseFormat.ts","webpack:///./src/dsl/generator/common/case-format/UpperUnderscoreCaseFormat.ts","webpack:///./src/dsl/generator/common/id-naming-strategy.ts","webpack:///./src/dsl/generator/database/database-model/database-model-generator.ts","webpack:///./src/dsl/generator/database/sql/mysql/my-sql-code-generator.ts","webpack:///./src/dsl/generator/database/sql/mysql/mysql-code-generator-config.ts","webpack:///./src/dsl/generator/oop/class-model/class-model-generator.ts","webpack:///./src/dsl/generator/oop/java/java-code-generator.ts","webpack:///./src/dsl/parser/er-model-parser.ts","webpack:///./src/dsl/parser/statement/statement-type-guesser.ts","webpack:///./src/dsl/parser/statement/statement-types-parse-functions.ts","webpack:///./src/dsl/parser/statement/statement-types-regexes.ts","webpack:///./src/dsl/util/regex-utils.ts","webpack:///./src/dsl/util/string-utils.ts","webpack:///./src/index.ts","webpack:///external \"assert\"","webpack:///external \"fs\"","webpack:///external \"path\"","webpack:///external \"util\""],"names":[],"mappings":";;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb,mBAAmB,kBAAkB,KAAK;AAC1C;AACA,4BAA4B,4BAA4B;AACxD,aAAa,IAAI,IAAI,IAAI,IAAI;AAC7B;;AAEA;AACA;;;;;;;;;;;;;ACTA,8CAAa;;AAEb;AACA;AACA,kBAAkB,cAAc;AAChC;;AAEA;AACA;AACA,kBAAkB,aAAa,EAAE,EAAE,KAAK;AACxC;;AAEA;AACA;AACA,kBAAkB,aAAa,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE,OAAO;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,4DAAe;AACxC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,qBAAqB,SAAS;AAC9B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AClKY;;AAEb;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3EY;;AAEZ,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,kBAAkB,mBAAO,CAAC,sDAAY;AACtC,aAAa,mBAAO,CAAC,oDAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACjWA;AACA;AACA,oBAAoB,mBAAO,CAAC,sDAAY;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,QAAQ,4BAA4B;AACpC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,2BAA2B;AAClC,OAAO,6BAA6B;AACpC,WAAW,iCAAiC;AAC5C,UAAU,gCAAgC;AAC1C,WAAW,iCAAiC;AAC5C,OAAO,qCAAqC;AAC5C,SAAS,2CAA2C;AACpD,QAAQ;AACR;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,QAAQ,iBAAiB;AACzB;AACA;AACA,oDAAoD,gBAAgB;AACpE,kDAAkD,cAAc;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,SAAS;AACjC,gBAAgB,QAAQ,SAAS;AACjC,iBAAiB,OAAO,QAAQ;AAChC,iBAAiB,OAAO,QAAQ;AAChC,gBAAgB,SAAS,OAAO;AAChC,gBAAgB,SAAS,OAAO;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yEAAyE;;AAEzE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,EAAE,UAAU,EAAE;AAC/D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa,aAAa;AACzC;AACA,eAAe,aAAa;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACt0BA,oBAAoB,mBAAO,CAAC,kEAAe;AAC3C,cAAc,mBAAO,CAAC,sDAAS;;AAE/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wDAAwD,uCAAuC;AAC/F,sDAAsD,qCAAqC;;AAE3F;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF,CAAC;;AAED;;;;;;;;;;;;AChFA,oBAAoB,mBAAO,CAAC,kEAAe;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AC/FY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvJa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZa;;AAEb;AACA;AACA;AACA;;;;;;;;;;;;;ACLa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,mBAAmB,mBAAO,CAAC,wDAAa;AACxC,mBAAmB,mBAAO,CAAC,wDAAa;;AAExC;;AAEA,0CAA0C;AAC1C;AACA,QAAQ,KAAK;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,2BAA2B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,QAAQ,KAAK;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gCAAgC,2BAA2B;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;ACxFa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACrBA;AACa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjDa;AACb,aAAa,mBAAO,CAAC,kBAAM;AAC3B,WAAW,mBAAO,CAAC,cAAI;AACvB,OAAO,UAAU,GAAG,mBAAO,CAAC,kBAAM;AAClC,gBAAgB,mBAAO,CAAC,kDAAU;;AAElC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,KAAK;AACzB;AACA;AACA;;AAEA,4CAA4C,KAAK;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AChEa;AACb,aAAa,mBAAO,CAAC,4CAAO;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;;;;;;;;;;;;ACxDa;AACb,eAAe,mBAAO,CAAC,gDAAS;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnDa;;AAEb;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;ACRa;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,OAAO,UAAU,GAAG,mBAAO,CAAC,kBAAM;;AAElC;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;;;;;;;;;;;ACtBA;;AAEA;AACA;AACA,MAAM,IAA0F;AAChG;AACA;AACA,GAAG,MAAM,EAQN;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA,8BAA8B,IAAI;AAClC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,MAAM;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACtfY;;AAEb,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,kBAAM;AACvB,YAAY,mBAAO,CAAC,kBAAM;AAC1B,YAAY,mBAAO,CAAC,kBAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,+E;;;;;;;;;;;ACRA;AACA,yBAAyB,0EAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACNa;AACb,kBAAkB,mBAAO,CAAC,sDAAY;AACtC,6BAA6B,mBAAO,CAAC,gFAAyB;AAC9D,mBAAmB,mBAAO,CAAC,wDAAa;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,mBAAmB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1Ca;AACb,kBAAkB,mBAAO,CAAC,sDAAY;;AAEtC;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;ACrBY;;AAEZ;AACA,sCAAsC,qBAAa,OAAO,kBAAkB;AAC5E,UAAU,qBAAa;AACvB;AACA;AACA;AACA;;;;;;;;;;;;;ACRa;AACb,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,kBAAkB,mBAAO,CAAC,sDAAY;AACtC,mBAAmB,mBAAO,CAAC,wDAAa;;AAExC;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,8BAA8B,GAAG,KAAK;;AAElE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzLA,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,+D;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,sE;;;;;;;;;;;ACRA,kBAAkB,mBAAO,CAAC,oDAAW;AACrC,mBAAmB,mBAAO,CAAC,sDAAY;AACvC,aAAa,mBAAO,CAAC,kBAAM;AAC3B,0BAA0B,mBAAO,CAAC,yFAA2B;AAC7D,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,GAAG;AACH;AACA;AACA,GAAG;;AAEH,6BAA6B;AAC7B;AACA;AACA,GAAG;;AAEH,+BAA+B;AAC/B;AACA;AACA,GAAG;;AAEH;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH,iCAAiC;AACjC;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;AAEA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,mCAAmC;AACjE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,qBAAqB,kEAAQ,kBAAkB,CAAC;AAChD;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA,uBAAuB;AACvB,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB,SAAS;AACT,8BAA8B;AAC9B;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C,0BAA0B,yBAAyB;AACnD;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvgCA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,yE;;;;;;;;;;;;ACRa;AACb,8CAA8C,cAAc;AAC5D;AACA,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,0DAAU;AACnC;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAe,CAAC,2FAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe,QAAQ,IAAI;AACpG;AACA;AACA,sFAAsF,qEAAQ,cAAc,CAAC;AAC7G;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,0DAAU;AACnC,wBAAwB,mBAAO,CAAC,wEAAiB;AACjD;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,uBAAuB,gBAAgB,YAAY;AACpI;AACA;AACA;AACA,mFAAmF,cAAc,gBAAgB,OAAO;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC,sBAAsB,0BAA0B,gBAAgB,aAAa;AAC1J;;;;;;;;;;;;;AChEa;AACb,8CAA8C,cAAc;AAC5D;AACA,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,wBAAwB,mBAAO,CAAC,wEAAiB;AACjD,aAAa,mBAAO,CAAC,kBAAM;AAC3B,eAAe,mBAAO,CAAC,kBAAM;AAC7B,gBAAgB,mBAAO,CAAC,wDAAS;AACjC,yBAAyB,mBAAO,CAAC,oEAAmB;AACpD,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,eAAe,mBAAO,CAAC,0DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qCAAqC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,oBAAoB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gCAAgC,EAAE;AACnF;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,uCAAuC;AACvC;AACA,SAAS;AACT,iEAAiE;AACjE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Za;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,sBAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBa;AACb,8CAA8C,cAAc;AAC5D;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA,kBAAkB,UAAU,GAAG,oBAAoB;AACnD,UAAU,UAAU,GAAG,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC,cAAc,cAAc;;AAE5B;AACA,kBAAkB,UAAU,6BAA6B,QAAQ;;AAEjE,iCAAiC,UAAU,QAAQ,SAAS;;AAE5D;AACA,YAAY,cAAc,SAAS;AACnC;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,UAAU,UAAU;AACpB;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA,kBAAkB,UAAU,GAAG,oBAAoB;AACnD,UAAU,UAAU,GAAG,oBAAoB;AAC3C;AACA,GAAG,UAAU;AACb;AACA;AACA;AACA,4FAA4F,UAAU,6BAA6B,SAAS;AAC5I;AACA;AACA;AACA,WAAW,UAAU,qBAAqB;AAC1C,UAAU,UAAU;AACpB;;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,4DAAW;AACrC,kBAAkB,mBAAO,CAAC,sFAAwB;AAClD,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,wBAAwB,mBAAO,CAAC,wEAAiB;AACjD,aAAa,mBAAO,CAAC,kBAAM;AAC3B,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY,EAAE;AAC9D,qBAAqB;AACrB,gDAAgD,WAAW,EAAE;AAC7D,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,IAAI;AAC5F;AACA,mFAAmF,IAAI;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB,GAAG,qCAAqC;AAC1H;AACA;AACA;AACA;AACA;AACA,4CAA4C,IAAI;AAChD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB,mCAAmC,UAAU;AAC7C,mCAAmC,oBAAoB;AACvD,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,eAAe,eAAe;AAC9B,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzDa;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,4DAAW;AACrC,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACxDa;AACb,8CAA8C,cAAc;AAC5D;AACA,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;ACba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,uDAAuD,GAAG;AAC1D;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;ACnCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9Ba;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,iBAAiB,mBAAO,CAAC,0DAAU;AACnC,mBAAmB,mBAAO,CAAC,sDAAY;AACvC,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,mBAAmB,mBAAO,CAAC,4CAAO;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,iCAAiC;AAC/D;AACA,gCAAgC,UAAU,SAAS,0BAA0B;AAC7E;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO,IAAI,cAAc;AACpD;AACA;AACA,2BAA2B,OAAO,IAAI,cAAc;AACpD;AACA,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,2BAA2B;AAC3F;AACA;AACA;AACA;AACA,yCAAyC,OAAO,GAAG,eAAe,EAAE,iCAAiC,EAAE;AACvG;AACA;AACA;AACA,0DAA0D,OAAO,EAAE,eAAe;AAClF,iBAAiB,GAAG,mBAAmB;AACvC;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,mCAAmC,eAAe,GAAG,sBAAsB;AAC3E;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA,uCAAuC,iBAAiB;AACxD;AACA;AACA;AACA,4BAA4B,+DAA+D;AAC3F;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAyC;AAClF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA,+BAA+B,YAAY;AAC3C;AACA,+BAA+B,aAAa;AAC5C;AACA,+BAA+B,aAAa;AAC5C;AACA,+BAA+B,YAAY;AAC3C;AACA,+BAA+B,aAAa;AAC5C;AACA,0BAA0B,iCAAiC;AAC3D,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,mDAAmD,eAAe;AAClE,kEAAkE,eAAe,GAAG,6CAA6C;AACjI;AACA;AACA,yBAAyB,+EAA+E;AACxG;AACA,4BAA4B,qDAAqD;AACjF;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,uDAAuD,SAAS,GAAG,KAAK;AACxE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;AC3hBa;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,4DAAW;AACrC,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,sBAAsB,mBAAO,CAAC,oEAAe;AAC7C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,sIAAsI;AAChK,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ,MAAM,UAAU;AAC/D;AACA,aAAa;AACb,SAAS;AACT;AACA,yBAAyB,2BAA2B;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,kCAAkC,kDAAkD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;ACzUA,iDAAa;AACb,8CAA8C,cAAc;AAC5D;AACA,kBAAkB,mBAAO,CAAC,4DAAW;AACrC,uBAAuB,mBAAO,CAAC,sEAAgB;AAC/C,iBAAiB,mBAAO,CAAC,0DAAU;AACnC,gBAAgB,mBAAO,CAAC,wDAAS;AACjC,kBAAkB,mBAAO,CAAC,4DAAW;AACrC,WAAW,mBAAO,CAAC,cAAI;AACvB,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,aAAa,mBAAO,CAAC,kBAAM;AAC3B,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,wBAAwB,mBAAO,CAAC,wEAAiB;AACjD,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,oBAAoB,mBAAO,CAAC,sEAAgB;AAC5C,qBAAqB,mBAAO,CAAC,kEAAc;AAC3C,eAAe,mBAAO,CAAC,0DAAc;AACrC,oBAAoB,mBAAO,CAAC,0CAAM;AAClC,oBAAoB,mBAAO,CAAC,0DAAc;AAC1C,eAAe,mBAAO,CAAC,gDAAS;AAChC,4BAA4B,mBAAO,CAAC,4EAAuB;AAC3D,sEAAsE,oEAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oEAAO;AAC5C,0DAA0D,mBAAO,CAAC,gEAAiB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,SAAS;AACT,6DAA6D;AAC7D;AACA,SAAS;AACT;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yBAAyB;AACnF;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,yBAAyB;AAC7F;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrqCa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVY;AACZ;AACA;AACA;AACA,cAAc,mBAAO,CAAC,8CAAS;AAC/B,oBAAoB,mBAAO,CAAC,gFAA0B;;AAEtD;;AAEA;;AAEA;AACA,uCAAuC,0DAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,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","file":"er-diagram-code-generator.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","'use strict';\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n","'use strict';\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = require('color-convert');\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n","'use strict';\n\nconst preserveCamelCase = string => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {\n\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {\n\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst camelCase = (input, options) => {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = Object.assign({\n\t\tpascalCase: false\n\t}, options);\n\n\tconst postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (input.length === 1) {\n\t\treturn options.pascalCase ? input.toUpperCase() : input.toLowerCase();\n\t}\n\n\tconst hasUpperCase = input !== input.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input);\n\t}\n\n\tinput = input\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (_, p1) => p1.toUpperCase())\n\t\t.replace(/\\d+(\\w|$)/g, m => m.toUpperCase());\n\n\treturn postProcess(input);\n};\n\nmodule.exports = camelCase;\n// TODO: Remove this for the next major release\nmodule.exports.default = camelCase;\n","'use strict'\n\nconst stringWidth = require('string-width')\nconst stripAnsi = require('strip-ansi')\nconst wrap = require('wrap-ansi')\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n}\nconst top = 0\nconst right = 1\nconst bottom = 2\nconst left = 3\n\nclass UI {\n  constructor (opts) {\n    this.width = opts.width\n    this.wrap = opts.wrap\n    this.rows = []\n  }\n\n  span (...args) {\n    const cols = this.div(...args)\n    cols.span = true\n  }\n\n  resetOutput () {\n    this.rows = []\n  }\n\n  div (...args) {\n    if (args.length === 0) {\n      this.div('')\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0])\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg)\n      }\n\n      return arg\n    })\n\n    this.rows.push(cols)\n    return cols\n  }\n\n  _shouldApplyLayoutDSL (...args) {\n    return args.length === 1 && typeof args[0] === 'string' &&\n      /[\\t\\n]/.test(args[0])\n  }\n\n  _applyLayoutDSL (str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'))\n    let leftColumnWidth = 0\n\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(\n          Math.floor(this.width * 0.5),\n          stringWidth(columns[0])\n        )\n      }\n    })\n\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n        }\n      }))\n    })\n\n    return this.rows[this.rows.length - 1]\n  }\n\n  _colFromString (text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    }\n  }\n\n  _measurePadding (str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str)\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length]\n  }\n\n  toString () {\n    const lines = []\n\n    this.rows.forEach(row => {\n      this.rowToString(row, lines)\n    })\n\n    // don't display any lines with the\n    // hidden flag set.\n    return lines\n      .filter(line => !line.hidden)\n      .map(line => line.text)\n      .join('\\n')\n  }\n\n  rowToString (row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = ''\n      rrow.forEach((col, c) => {\n        const { width } = row[c] // the width with padding.\n        const wrapWidth = this._negatePadding(row[c]) // the width without padding.\n\n        let ts = col // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col))\n        }\n\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth)\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1)\n          }\n        }\n\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0]\n        if (padding[left]) {\n          str += ' '.repeat(padding[left])\n        }\n\n        str += addBorder(row[c], ts, '| ')\n        str += ts\n        str += addBorder(row[c], ts, ' |')\n        if (padding[right]) {\n          str += ' '.repeat(padding[right])\n        }\n\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1])\n        }\n      })\n\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      })\n    })\n\n    return lines\n  }\n\n  // if the full 'source' can render in\n  // the target line, do so.\n  _renderInline (source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length\n    const target = previousLine.text\n    const targetTextWidth = stringWidth(target.trimRight())\n\n    if (!previousLine.span) {\n      return source\n    }\n\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true\n      return target + source\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source\n    }\n\n    previousLine.hidden = true\n\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft()\n  }\n\n  _rasterize (row) {\n    const rrows = []\n    const widths = this._columnWidths(row)\n    let wrapped\n\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c]\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), { hard: true }).split('\\n')\n      } else {\n        wrapped = col.text.split('\\n')\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.')\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\")\n      }\n\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''))\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''))\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([])\n        }\n\n        const rrow = rrows[r]\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('')\n          }\n        }\n\n        rrow.push(str)\n      })\n    })\n\n    return rrows\n  }\n\n  _negatePadding (col) {\n    let wrapWidth = col.width\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)\n    }\n\n    if (col.border) {\n      wrapWidth -= 4\n    }\n\n    return wrapWidth\n  }\n\n  _columnWidths (row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text)\n      })\n    }\n\n    let unset = row.length\n    let remainingWidth = this.width\n\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--\n        remainingWidth -= col.width\n        return col.width\n      }\n\n      return undefined\n    })\n\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0\n\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]))\n      }\n\n      return w\n    })\n  }\n}\n\nfunction addBorder (col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return ''\n    }\n\n    if (ts.trim().length !== 0) {\n      return style\n    }\n\n    return '  '\n  }\n\n  return ''\n}\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth (col) {\n  const padding = col.padding || []\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)\n  if (col.border) {\n    return minWidth + 4\n  }\n\n  return minWidth\n}\n\nfunction getWindowWidth () {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns\n  }\n}\n\nfunction alignRight (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str\n  }\n\n  return str\n}\n\nfunction alignCenter (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str\n  }\n\n  return ' '.repeat((width - strWidth) >> 1) + str\n}\n\nmodule.exports = function (opts = {}) {\n  return new UI({\n    width: opts.width || getWindowWidth() || /* istanbul ignore next */ 80,\n    wrap: opts.wrap !== false\n  })\n}\n","/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = require('color-name');\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n","const conversions = require('./conversions');\nconst route = require('./route');\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n","const conversions = require('./conversions');\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n","'use strict'\r\n\r\nmodule.exports = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\r\n","'use strict';\nmodule.exports = function (str, sep) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tsep = typeof sep === 'undefined' ? '_' : sep;\n\n\treturn str\n\t\t.replace(/([a-z\\d])([A-Z])/g, '$1' + sep + '$2')\n\t\t.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + sep + '$2')\n\t\t.toLowerCase();\n};\n","\"use strict\";\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n};\n","'use strict';\nconst path = require('path');\nconst locatePath = require('locate-path');\nconst pathExists = require('path-exists');\n\nconst stop = Symbol('findUp.stop');\n\nmodule.exports = async (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = async locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = await name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst foundPath = await runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.sync = (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath.sync(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath.sync([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst foundPath = runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.exists = pathExists;\n\nmodule.exports.sync.exists = pathExists.sync;\n\nmodule.exports.stop = stop;\n","\"use strict\";\n// Call this function in a another function to find out the file from\n// which that function was called from. (Inspects the v8 stack trace)\n//\n// Inspired by http://stackoverflow.com/questions/13227489\nmodule.exports = function getCallerFile(position) {\n    if (position === void 0) { position = 2; }\n    if (position >= Error.stackTraceLimit) {\n        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');\n    }\n    var oldPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = new Error().stack;\n    Error.prepareStackTrace = oldPrepareStackTrace;\n    if (stack !== null && typeof stack === 'object') {\n        // stack[0] holds this file\n        // stack[1] holds where this function was called\n        // stack[2] holds the file we're interested in\n        return stack[position] ? stack[position].getFileName() : undefined;\n    }\n};\n//# sourceMappingURL=index.js.map","/* eslint-disable yoda */\n'use strict';\n\nconst isFullwidthCodePoint = codePoint => {\n\tif (Number.isNaN(codePoint)) {\n\t\treturn false;\n\t}\n\n\t// Code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tcodePoint >= 0x1100 && (\n\t\t\tcodePoint <= 0x115F || // Hangul Jamo\n\t\t\tcodePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tcodePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= codePoint && codePoint <= 0x4DBF) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xA960 <= codePoint && codePoint <= 0xA97C) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xF900 <= codePoint && codePoint <= 0xFAFF) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xFE10 <= codePoint && codePoint <= 0xFE19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xFF01 <= codePoint && codePoint <= 0xFF60) ||\n\t\t\t(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1B000 <= codePoint && codePoint <= 0x1B001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1F200 <= codePoint && codePoint <= 0x1F251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= codePoint && codePoint <= 0x3FFFD)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nmodule.exports = isFullwidthCodePoint;\nmodule.exports.default = isFullwidthCodePoint;\n","'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst {promisify} = require('util');\nconst pLocate = require('p-locate');\n\nconst fsStat = promisify(fs.stat);\nconst fsLStat = promisify(fs.lstat);\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile'\n};\n\nfunction checkType({type}) {\n\tif (type in typeMappings) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();\n\nmodule.exports = async (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\ttype: 'file',\n\t\tallowSymlinks: true,\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fsStat : fsLStat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFn(path.resolve(options.cwd, path_));\n\t\t\treturn matchType(options.type, stat);\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t}, options);\n};\n\nmodule.exports.sync = (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tallowSymlinks: true,\n\t\ttype: 'file',\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFn(path.resolve(options.cwd, path_));\n\n\t\t\tif (matchType(options.type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch (_) {\n\t\t}\n\t}\n};\n","'use strict';\nconst pTry = require('p-try');\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\treturn Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\tconst run = (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = pTry(fn, ...args);\n\n\t\tresolve(result);\n\n\t\tresult.then(next, next);\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tif (activeCount < concurrency) {\n\t\t\trun(fn, resolve, ...args);\n\t\t} else {\n\t\t\tqueue.push(run.bind(null, fn, resolve, ...args));\n\t\t}\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.length\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.length = 0;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\nmodule.exports.default = pLimit;\n","'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n","'use strict';\n\nconst pTry = (fn, ...arguments_) => new Promise(resolve => {\n\tresolve(fn(...arguments_));\n});\n\nmodule.exports = pTry;\n// TODO: remove this in the next major version\nmodule.exports.default = pTry;\n","'use strict';\nconst fs = require('fs');\nconst {promisify} = require('util');\n\nconst pAccess = promisify(fs.access);\n\nmodule.exports = async path => {\n\ttry {\n\t\tawait pAccess(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nmodule.exports.sync = path => {\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n","/* global define */\n\n(function (root, pluralize) {\n  /* istanbul ignore else */\n  if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {\n    // Node.\n    module.exports = pluralize();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD, registers as an anonymous module.\n    define(function () {\n      return pluralize();\n    });\n  } else {\n    // Browser global.\n    root.pluralize = pluralize();\n  }\n})(this, function () {\n  // Rule storage - pluralize and singularize need to be run sequentially,\n  // while other rules can be optimized using an object for instant lookups.\n  var pluralRules = [];\n  var singularRules = [];\n  var uncountables = {};\n  var irregularPlurals = {};\n  var irregularSingles = {};\n\n  /**\n   * Sanitize a pluralization rule to a usable regular expression.\n   *\n   * @param  {(RegExp|string)} rule\n   * @return {RegExp}\n   */\n  function sanitizeRule (rule) {\n    if (typeof rule === 'string') {\n      return new RegExp('^' + rule + '$', 'i');\n    }\n\n    return rule;\n  }\n\n  /**\n   * Pass in a word token to produce a function that can replicate the case on\n   * another word.\n   *\n   * @param  {string}   word\n   * @param  {string}   token\n   * @return {Function}\n   */\n  function restoreCase (word, token) {\n    // Tokens are an exact match.\n    if (word === token) return token;\n\n    // Lower cased words. E.g. \"hello\".\n    if (word === word.toLowerCase()) return token.toLowerCase();\n\n    // Upper cased words. E.g. \"WHISKY\".\n    if (word === word.toUpperCase()) return token.toUpperCase();\n\n    // Title cased words. E.g. \"Title\".\n    if (word[0] === word[0].toUpperCase()) {\n      return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();\n    }\n\n    // Lower cased words. E.g. \"test\".\n    return token.toLowerCase();\n  }\n\n  /**\n   * Interpolate a regexp string.\n   *\n   * @param  {string} str\n   * @param  {Array}  args\n   * @return {string}\n   */\n  function interpolate (str, args) {\n    return str.replace(/\\$(\\d{1,2})/g, function (match, index) {\n      return args[index] || '';\n    });\n  }\n\n  /**\n   * Replace a word using a rule.\n   *\n   * @param  {string} word\n   * @param  {Array}  rule\n   * @return {string}\n   */\n  function replace (word, rule) {\n    return word.replace(rule[0], function (match, index) {\n      var result = interpolate(rule[1], arguments);\n\n      if (match === '') {\n        return restoreCase(word[index - 1], result);\n      }\n\n      return restoreCase(match, result);\n    });\n  }\n\n  /**\n   * Sanitize a word by passing in the word and sanitization rules.\n   *\n   * @param  {string}   token\n   * @param  {string}   word\n   * @param  {Array}    rules\n   * @return {string}\n   */\n  function sanitizeWord (token, word, rules) {\n    // Empty string or doesn't need fixing.\n    if (!token.length || uncountables.hasOwnProperty(token)) {\n      return word;\n    }\n\n    var len = rules.length;\n\n    // Iterate over the sanitization rules and use the first one to match.\n    while (len--) {\n      var rule = rules[len];\n\n      if (rule[0].test(word)) return replace(word, rule);\n    }\n\n    return word;\n  }\n\n  /**\n   * Replace a word with the updated word.\n   *\n   * @param  {Object}   replaceMap\n   * @param  {Object}   keepMap\n   * @param  {Array}    rules\n   * @return {Function}\n   */\n  function replaceWord (replaceMap, keepMap, rules) {\n    return function (word) {\n      // Get the correct token and case restoration functions.\n      var token = word.toLowerCase();\n\n      // Check against the keep object map.\n      if (keepMap.hasOwnProperty(token)) {\n        return restoreCase(word, token);\n      }\n\n      // Check against the replacement map for a direct word replacement.\n      if (replaceMap.hasOwnProperty(token)) {\n        return restoreCase(word, replaceMap[token]);\n      }\n\n      // Run all the rules against the word.\n      return sanitizeWord(token, word, rules);\n    };\n  }\n\n  /**\n   * Check if a word is part of the map.\n   */\n  function checkWord (replaceMap, keepMap, rules, bool) {\n    return function (word) {\n      var token = word.toLowerCase();\n\n      if (keepMap.hasOwnProperty(token)) return true;\n      if (replaceMap.hasOwnProperty(token)) return false;\n\n      return sanitizeWord(token, token, rules) === token;\n    };\n  }\n\n  /**\n   * Pluralize or singularize a word based on the passed in count.\n   *\n   * @param  {string}  word      The word to pluralize\n   * @param  {number}  count     How many of the word exist\n   * @param  {boolean} inclusive Whether to prefix with the number (e.g. 3 ducks)\n   * @return {string}\n   */\n  function pluralize (word, count, inclusive) {\n    var pluralized = count === 1\n      ? pluralize.singular(word) : pluralize.plural(word);\n\n    return (inclusive ? count + ' ' : '') + pluralized;\n  }\n\n  /**\n   * Pluralize a word.\n   *\n   * @type {Function}\n   */\n  pluralize.plural = replaceWord(\n    irregularSingles, irregularPlurals, pluralRules\n  );\n\n  /**\n   * Check if a word is plural.\n   *\n   * @type {Function}\n   */\n  pluralize.isPlural = checkWord(\n    irregularSingles, irregularPlurals, pluralRules\n  );\n\n  /**\n   * Singularize a word.\n   *\n   * @type {Function}\n   */\n  pluralize.singular = replaceWord(\n    irregularPlurals, irregularSingles, singularRules\n  );\n\n  /**\n   * Check if a word is singular.\n   *\n   * @type {Function}\n   */\n  pluralize.isSingular = checkWord(\n    irregularPlurals, irregularSingles, singularRules\n  );\n\n  /**\n   * Add a pluralization rule to the collection.\n   *\n   * @param {(string|RegExp)} rule\n   * @param {string}          replacement\n   */\n  pluralize.addPluralRule = function (rule, replacement) {\n    pluralRules.push([sanitizeRule(rule), replacement]);\n  };\n\n  /**\n   * Add a singularization rule to the collection.\n   *\n   * @param {(string|RegExp)} rule\n   * @param {string}          replacement\n   */\n  pluralize.addSingularRule = function (rule, replacement) {\n    singularRules.push([sanitizeRule(rule), replacement]);\n  };\n\n  /**\n   * Add an uncountable word rule.\n   *\n   * @param {(string|RegExp)} word\n   */\n  pluralize.addUncountableRule = function (word) {\n    if (typeof word === 'string') {\n      uncountables[word.toLowerCase()] = true;\n      return;\n    }\n\n    // Set singular and plural references for the word.\n    pluralize.addPluralRule(word, '$0');\n    pluralize.addSingularRule(word, '$0');\n  };\n\n  /**\n   * Add an irregular word definition.\n   *\n   * @param {string} single\n   * @param {string} plural\n   */\n  pluralize.addIrregularRule = function (single, plural) {\n    plural = plural.toLowerCase();\n    single = single.toLowerCase();\n\n    irregularSingles[single] = plural;\n    irregularPlurals[plural] = single;\n  };\n\n  /**\n   * Irregular rules.\n   */\n  [\n    // Pronouns.\n    ['I', 'we'],\n    ['me', 'us'],\n    ['he', 'they'],\n    ['she', 'they'],\n    ['them', 'them'],\n    ['myself', 'ourselves'],\n    ['yourself', 'yourselves'],\n    ['itself', 'themselves'],\n    ['herself', 'themselves'],\n    ['himself', 'themselves'],\n    ['themself', 'themselves'],\n    ['is', 'are'],\n    ['was', 'were'],\n    ['has', 'have'],\n    ['this', 'these'],\n    ['that', 'those'],\n    // Words ending in with a consonant and `o`.\n    ['echo', 'echoes'],\n    ['dingo', 'dingoes'],\n    ['volcano', 'volcanoes'],\n    ['tornado', 'tornadoes'],\n    ['torpedo', 'torpedoes'],\n    // Ends with `us`.\n    ['genus', 'genera'],\n    ['viscus', 'viscera'],\n    // Ends with `ma`.\n    ['stigma', 'stigmata'],\n    ['stoma', 'stomata'],\n    ['dogma', 'dogmata'],\n    ['lemma', 'lemmata'],\n    ['schema', 'schemata'],\n    ['anathema', 'anathemata'],\n    // Other irregular rules.\n    ['ox', 'oxen'],\n    ['axe', 'axes'],\n    ['die', 'dice'],\n    ['yes', 'yeses'],\n    ['foot', 'feet'],\n    ['eave', 'eaves'],\n    ['goose', 'geese'],\n    ['tooth', 'teeth'],\n    ['quiz', 'quizzes'],\n    ['human', 'humans'],\n    ['proof', 'proofs'],\n    ['carve', 'carves'],\n    ['valve', 'valves'],\n    ['looey', 'looies'],\n    ['thief', 'thieves'],\n    ['groove', 'grooves'],\n    ['pickaxe', 'pickaxes'],\n    ['passerby', 'passersby']\n  ].forEach(function (rule) {\n    return pluralize.addIrregularRule(rule[0], rule[1]);\n  });\n\n  /**\n   * Pluralization rules.\n   */\n  [\n    [/s?$/i, 's'],\n    [/[^\\u0000-\\u007F]$/i, '$0'],\n    [/([^aeiou]ese)$/i, '$1'],\n    [/(ax|test)is$/i, '$1es'],\n    [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, '$1es'],\n    [/(e[mn]u)s?$/i, '$1s'],\n    [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, '$1'],\n    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],\n    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],\n    [/(seraph|cherub)(?:im)?$/i, '$1im'],\n    [/(her|at|gr)o$/i, '$1oes'],\n    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],\n    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],\n    [/sis$/i, 'ses'],\n    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],\n    [/([^aeiouy]|qu)y$/i, '$1ies'],\n    [/([^ch][ieo][ln])ey$/i, '$1ies'],\n    [/(x|ch|ss|sh|zz)$/i, '$1es'],\n    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],\n    [/\\b((?:tit)?m|l)(?:ice|ouse)$/i, '$1ice'],\n    [/(pe)(?:rson|ople)$/i, '$1ople'],\n    [/(child)(?:ren)?$/i, '$1ren'],\n    [/eaux$/i, '$0'],\n    [/m[ae]n$/i, 'men'],\n    ['thou', 'you']\n  ].forEach(function (rule) {\n    return pluralize.addPluralRule(rule[0], rule[1]);\n  });\n\n  /**\n   * Singularization rules.\n   */\n  [\n    [/s$/i, ''],\n    [/(ss)$/i, '$1'],\n    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\\w]|^)li)ves$/i, '$1fe'],\n    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],\n    [/ies$/i, 'y'],\n    [/\\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, '$1ie'],\n    [/\\b(mon|smil)ies$/i, '$1ey'],\n    [/\\b((?:tit)?m|l)ice$/i, '$1ouse'],\n    [/(seraph|cherub)im$/i, '$1'],\n    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, '$1'],\n    [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, '$1sis'],\n    [/(movie|twelve|abuse|e[mn]u)s$/i, '$1'],\n    [/(test)(?:is|es)$/i, '$1is'],\n    [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],\n    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],\n    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],\n    [/(alumn|alg|vertebr)ae$/i, '$1a'],\n    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],\n    [/(matr|append)ices$/i, '$1ix'],\n    [/(pe)(rson|ople)$/i, '$1rson'],\n    [/(child)ren$/i, '$1'],\n    [/(eau)x?$/i, '$1'],\n    [/men$/i, 'man']\n  ].forEach(function (rule) {\n    return pluralize.addSingularRule(rule[0], rule[1]);\n  });\n\n  /**\n   * Uncountable rules.\n   */\n  [\n    // Singular words with no plurals.\n    'adulthood',\n    'advice',\n    'agenda',\n    'aid',\n    'aircraft',\n    'alcohol',\n    'ammo',\n    'analytics',\n    'anime',\n    'athletics',\n    'audio',\n    'bison',\n    'blood',\n    'bream',\n    'buffalo',\n    'butter',\n    'carp',\n    'cash',\n    'chassis',\n    'chess',\n    'clothing',\n    'cod',\n    'commerce',\n    'cooperation',\n    'corps',\n    'debris',\n    'diabetes',\n    'digestion',\n    'elk',\n    'energy',\n    'equipment',\n    'excretion',\n    'expertise',\n    'firmware',\n    'flounder',\n    'fun',\n    'gallows',\n    'garbage',\n    'graffiti',\n    'hardware',\n    'headquarters',\n    'health',\n    'herpes',\n    'highjinks',\n    'homework',\n    'housework',\n    'information',\n    'jeans',\n    'justice',\n    'kudos',\n    'labour',\n    'literature',\n    'machinery',\n    'mackerel',\n    'mail',\n    'media',\n    'mews',\n    'moose',\n    'music',\n    'mud',\n    'manga',\n    'news',\n    'only',\n    'personnel',\n    'pike',\n    'plankton',\n    'pliers',\n    'police',\n    'pollution',\n    'premises',\n    'rain',\n    'research',\n    'rice',\n    'salmon',\n    'scissors',\n    'series',\n    'sewage',\n    'shambles',\n    'shrimp',\n    'software',\n    'species',\n    'staff',\n    'swine',\n    'tennis',\n    'traffic',\n    'transportation',\n    'trout',\n    'tuna',\n    'wealth',\n    'welfare',\n    'whiting',\n    'wildebeest',\n    'wildlife',\n    'you',\n    /pok[eé]mon$/i,\n    // Regexes.\n    /[^aeiou]ese$/i, // \"chinese\", \"japanese\"\n    /deer$/i, // \"deer\", \"reindeer\"\n    /fish$/i, // \"fish\", \"blowfish\", \"angelfish\"\n    /measles$/i,\n    /o[iu]s$/i, // \"carnivorous\"\n    /pox$/i, // \"chickpox\", \"smallpox\"\n    /sheep$/i\n  ].forEach(pluralize.addUncountableRule);\n\n  return pluralize;\n});\n","'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\n\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/require-main-filename sync recursive\";","module.exports = function (_require) {\n  _require = _require || require\n  var main = _require.main\n  if (main && isIISNode(main)) return handleIISNode(main)\n  else return main ? main.filename : process.cwd()\n}\n\nfunction isIISNode (main) {\n  return /\\\\iisnode\\\\/.test(main.filename)\n}\n\nfunction handleIISNode (main) {\n  if (!main.children.length) {\n    return main.filename\n  } else {\n    return main.children[0].filename\n  }\n}\n","module.exports = function (blocking) {\n  [process.stdout, process.stderr].forEach(function (stream) {\n    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {\n      stream._handle.setBlocking(blocking)\n    }\n  })\n}\n","'use strict';\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\nconst emojiRegex = require('emoji-regex');\n\nconst stringWidth = string => {\n\tstring = string.replace(emojiRegex(), '  ');\n\n\tif (typeof string !== 'string' || string.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstring = stripAnsi(string);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst code = string.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n\nmodule.exports = stringWidth;\n// TODO: remove this in the next major version\nmodule.exports.default = stringWidth;\n","'use strict';\nconst ansiRegex = require('ansi-regex');\n\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","'use strict'\n\nmodule.exports = function whichModule (exported) {\n  for (var i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) {\n    mod = require.cache[files[i]]\n    if (mod.exports === exported) return mod\n  }\n  return null\n}\n","'use strict';\nconst stringWidth = require('string-width');\nconst stripAnsi = require('strip-ansi');\nconst ansiStyles = require('ansi-styles');\n\nconst ESCAPES = new Set([\n\t'\\u001B',\n\t'\\u009B'\n]);\n\nconst END_CODE = 39;\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = string => string.split(' ').map(character => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns) => {\n\tconst characters = [...word];\n\n\tlet isInsideEscape = false;\n\tlet visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tconst characterLength = stringWidth(character);\n\n\t\tif (visible + characterLength <= columns) {\n\t\t\trows[rows.length - 1] += character;\n\t\t} else {\n\t\t\trows.push(character);\n\t\t\tvisible = 0;\n\t\t}\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tisInsideEscape = true;\n\t\t} else if (isInsideEscape && character === 'm') {\n\t\t\tisInsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isInsideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible += characterLength;\n\n\t\tif (visible === columns && index < characters.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// It's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = str => {\n\tconst words = str.split(' ');\n\tlet last = words.length;\n\n\twhile (last > 0) {\n\t\tif (stringWidth(words[last - 1]) > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast--;\n\t}\n\n\tif (last === words.length) {\n\t\treturn str;\n\t}\n\n\treturn words.slice(0, last).join(' ') + words.slice(last).join('');\n};\n\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {}) => {\n\tif (options.trim !== false && string.trim() === '') {\n\t\treturn '';\n\t}\n\n\tlet pre = '';\n\tlet ret = '';\n\tlet escapeCode;\n\n\tconst lengths = wordLengths(string);\n\tlet rows = [''];\n\n\tfor (const [index, word] of string.split(' ').entries()) {\n\t\tif (options.trim !== false) {\n\t\t\trows[rows.length - 1] = rows[rows.length - 1].trimLeft();\n\t\t}\n\n\t\tlet rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (index !== 0) {\n\t\t\tif (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n\t\t\t\t// If we start with a new word but the current row length equals the length of the columns, add a new row\n\t\t\t\trows.push('');\n\t\t\t\trowLength = 0;\n\t\t\t}\n\n\t\t\tif (rowLength > 0 || options.trim === false) {\n\t\t\t\trows[rows.length - 1] += ' ';\n\t\t\t\trowLength++;\n\t\t\t}\n\t\t}\n\n\t\t// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n\t\tif (options.hard && lengths[index] > columns) {\n\t\t\tconst remainingColumns = (columns - rowLength);\n\t\t\tconst breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n\t\t\tconst breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n\t\t\tif (breaksStartingNextLine < breaksStartingThisLine) {\n\t\t\t\trows.push('');\n\t\t\t}\n\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < columns) {\n\t\t\t\twrapWord(rows, word, columns);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && options.wordWrap === false) {\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tif (options.trim !== false) {\n\t\trows = rows.map(stringVisibleTrimSpacesRight);\n\t}\n\n\tpre = rows.join('\\n');\n\n\tfor (const [index, character] of [...pre].entries()) {\n\t\tret += character;\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tconst code = parseFloat(/\\d[^m]*/.exec(pre.slice(index, index + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tconst code = ansiStyles.codes.get(Number(escapeCode));\n\n\t\tif (escapeCode && code) {\n\t\t\tif (pre[index + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(code);\n\t\t\t} else if (character === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options) => {\n\treturn String(string)\n\t\t.normalize()\n\t\t.replace(/\\r\\n/g, '\\n')\n\t\t.split('\\n')\n\t\t.map(line => exec(line, columns, options))\n\t\t.join('\\n');\n};\n","var fs = require('fs')\nvar path = require('path')\nvar util = require('util')\n\nfunction Y18N (opts) {\n  // configurable options.\n  opts = opts || {}\n  this.directory = opts.directory || './locales'\n  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true\n  this.locale = opts.locale || 'en'\n  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true\n\n  // internal stuff.\n  this.cache = Object.create(null)\n  this.writeQueue = []\n}\n\nY18N.prototype.__ = function () {\n  if (typeof arguments[0] !== 'string') {\n    return this._taggedLiteral.apply(this, arguments)\n  }\n  var args = Array.prototype.slice.call(arguments)\n  var str = args.shift()\n  var cb = function () {} // start with noop.\n\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n  cb = cb || function () {} // noop.\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][str] && this.updateFiles) {\n    this.cache[this.locale][str] = str\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))\n}\n\nY18N.prototype._taggedLiteral = function (parts) {\n  var args = arguments\n  var str = ''\n  parts.forEach(function (part, i) {\n    var arg = args[i + 1]\n    str += part\n    if (typeof arg !== 'undefined') {\n      str += '%s'\n    }\n  })\n  return this.__.apply(null, [str].concat([].slice.call(arguments, 1)))\n}\n\nY18N.prototype._enqueueWrite = function (work) {\n  this.writeQueue.push(work)\n  if (this.writeQueue.length === 1) this._processWriteQueue()\n}\n\nY18N.prototype._processWriteQueue = function () {\n  var _this = this\n  var work = this.writeQueue[0]\n\n  // destructure the enqueued work.\n  var directory = work[0]\n  var locale = work[1]\n  var cb = work[2]\n\n  var languageFile = this._resolveLocaleFile(directory, locale)\n  var serializedLocale = JSON.stringify(this.cache[locale], null, 2)\n\n  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n    _this.writeQueue.shift()\n    if (_this.writeQueue.length > 0) _this._processWriteQueue()\n    cb(err)\n  })\n}\n\nY18N.prototype._readLocaleFile = function () {\n  var localeLookup = {}\n  var languageFile = this._resolveLocaleFile(this.directory, this.locale)\n\n  try {\n    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      err.message = 'syntax error in ' + languageFile\n    }\n\n    if (err.code === 'ENOENT') localeLookup = {}\n    else throw err\n  }\n\n  this.cache[this.locale] = localeLookup\n}\n\nY18N.prototype._resolveLocaleFile = function (directory, locale) {\n  var file = path.resolve(directory, './', locale + '.json')\n  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n    // attempt fallback to language only\n    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')\n    if (this._fileExistsSync(languageFile)) file = languageFile\n  }\n  return file\n}\n\n// this only exists because fs.existsSync() \"will be deprecated\"\n// see https://nodejs.org/api/fs.html#fs_fs_existssync_path\nY18N.prototype._fileExistsSync = function (file) {\n  try {\n    return fs.statSync(file).isFile()\n  } catch (err) {\n    return false\n  }\n}\n\nY18N.prototype.__n = function () {\n  var args = Array.prototype.slice.call(arguments)\n  var singular = args.shift()\n  var plural = args.shift()\n  var quantity = args.shift()\n\n  var cb = function () {} // start with noop.\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  var str = quantity === 1 ? singular : plural\n  if (this.cache[this.locale][singular]) {\n    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']\n  }\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][singular] && this.updateFiles) {\n    this.cache[this.locale][singular] = {\n      one: singular,\n      other: plural\n    }\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  // if a %d placeholder is provided, add quantity\n  // to the arguments expanded by util.format.\n  var values = [str]\n  if (~str.indexOf('%d')) values.push(quantity)\n\n  return util.format.apply(util, values.concat(args))\n}\n\nY18N.prototype.setLocale = function (locale) {\n  this.locale = locale\n}\n\nY18N.prototype.getLocale = function () {\n  return this.locale\n}\n\nY18N.prototype.updateLocale = function (obj) {\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  for (var key in obj) {\n    this.cache[this.locale][key] = obj[key]\n  }\n}\n\nmodule.exports = function (opts) {\n  var y18n = new Y18N(opts)\n\n  // bind all functions to y18n, so that\n  // they can be used in isolation.\n  for (var key in y18n) {\n    if (typeof y18n[key] === 'function') {\n      y18n[key] = y18n[key].bind(y18n)\n    }\n  }\n\n  return y18n\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/yargs sync recursive\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/yargs-parser sync recursive\";","const camelCase = require('camelcase')\nconst decamelize = require('decamelize')\nconst path = require('path')\nconst tokenizeArgString = require('./lib/tokenize-arg-string')\nconst util = require('util')\n\nfunction parse (args, opts) {\n  opts = Object.assign(Object.create(null), opts)\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n\n  // aliases might have transitive relationships, normalize this.\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias))\n  const configuration = Object.assign({\n    'boolean-negation': true,\n    'camel-case-expansion': true,\n    'combine-arrays': false,\n    'dot-notation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'greedy-arrays': true,\n    'halt-at-non-option': false,\n    'nargs-eats-options': false,\n    'negation-prefix': 'no-',\n    'parse-numbers': true,\n    'populate--': false,\n    'set-placeholder-key': false,\n    'short-option-groups': true,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration)\n  const defaults = Object.assign(Object.create(null), opts.default)\n  const configObjects = opts.configObjects || []\n  const envPrefix = opts.envPrefix\n  const notFlagsOption = configuration['populate--']\n  const notFlagsArgv = notFlagsOption ? '--' : '_'\n  const newAliases = Object.create(null)\n  const defaulted = Object.create(null)\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  const __ = opts.__ || util.format\n  const flags = {\n    aliases: Object.create(null),\n    arrays: Object.create(null),\n    bools: Object.create(null),\n    strings: Object.create(null),\n    numbers: Object.create(null),\n    counts: Object.create(null),\n    normalize: Object.create(null),\n    configs: Object.create(null),\n    nargs: Object.create(null),\n    coercions: Object.create(null),\n    keys: []\n  }\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    const key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  let error = null\n  checkConfiguration()\n\n  let notFlags = []\n\n  const argv = Object.assign(Object.create(null), { _: [] })\n  // TODO(bcoe): for the first pass at removing object prototype  we didn't\n  // remove all prototypes from objects returned by this API, we might want\n  // to gradually move towards doing so.\n  const argvReturn = {}\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]\n    let broken\n    let key\n    let letters\n    let m\n    let next\n    let value\n\n    // any unknown option (except for end-of-options, \"--\")\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n      argv._.push(arg)\n    // -- separated by =\n    } else if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // arrays format = '--f=a b c'\n      if (checkAllAliases(m[1], flags.arrays)) {\n        i = eatArray(i, m[1], args, m[2])\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n        // nargs format = '--f=monkey washing cat'\n        i = eatNargs(i, m[1], args, m[2])\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false)\n\n    // -- separated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      if (checkAllAliases(key, flags.arrays)) {\n        // array format = '--foo a b c'\n        i = eatArray(i, key, args)\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\n        // nargs format = '--foo a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        i = eatNargs(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultValue(key))\n        }\n      }\n\n    // dot-notation flag separated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultValue(key))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f=a b c'\n            i = eatArray(i, key, args, value)\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f=monkey washing cat'\n            i = eatNargs(i, key, args, value)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultValue(letters[j]))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        if (checkAllAliases(key, flags.arrays)) {\n          // array format = '-f a b c'\n          i = eatArray(i, key, args)\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\n          // nargs format = '-f a b c'\n          // should be truthy even if: flags.nargs[key] === 0\n          i = eatNargs(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultValue(key))\n          }\n        }\n      }\n    } else if (arg.match(/^-[0-9]$/) &&\n      arg.match(negative) &&\n      checkAllAliases(arg.slice(1), flags.bools)) {\n      // single-digit boolean alias, e.g: xargs -0\n      key = arg.slice(1)\n      setArg(key, defaultValue(key))\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key]\n    })\n  }\n\n  if (configuration['strip-aliased']) {\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\n      }\n\n      delete argv[alias]\n    })\n  }\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args, argAfterEqualSign) {\n    let ii\n    let toEat = checkAllAliases(key, flags.nargs)\n    // NaN has a special meaning for the array type, indicating that one or\n    // more values are expected.\n    toEat = isNaN(toEat) ? 1 : toEat\n\n    if (toEat === 0) {\n      if (!isUndefined(argAfterEqualSign)) {\n        error = Error(__('Argument unexpected for: %s', key))\n      }\n      setArg(key, defaultValue(key))\n      return i\n    }\n\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1\n    if (configuration['nargs-eats-options']) {\n      // classic behavior, yargs eats positional and dash arguments.\n      if (args.length - (i + 1) + available < toEat) {\n        error = Error(__('Not enough arguments following: %s', key))\n      }\n      available = toEat\n    } else {\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\n      // and terminates when one is observed.\n      for (ii = i + 1; ii < args.length; ii++) {\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++\n        else break\n      }\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    let consumed = Math.min(available, toEat)\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n      setArg(key, argAfterEqualSign)\n      consumed--\n    }\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args, argAfterEqualSign) {\n    let argsToSet = []\n    let next = argAfterEqualSign || args[i + 1]\n    // If both array and nargs are configured, enforce the nargs count:\n    const nargsCount = checkAllAliases(key, flags.nargs)\n\n    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n      argsToSet.push(true)\n    } else if (isUndefined(next) ||\n        (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults[key] !== undefined) {\n        const defVal = defaults[key]\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal]\n      }\n    } else {\n      // value in --option=value is eaten as is\n      if (!isUndefined(argAfterEqualSign)) {\n        argsToSet.push(processValue(key, argAfterEqualSign))\n      }\n      for (let ii = i + 1; ii < args.length; ii++) {\n        if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n          (nargsCount && argsToSet.length >= nargsCount)) break\n        next = args[ii]\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break\n        i = ii\n        argsToSet.push(processValue(key, next))\n      }\n    }\n\n    // If both array and nargs are configured, create an error if less than\n    // nargs positionals were found. NaN has special meaning, indicating\n    // that at least one value is required (more are okay).\n    if ((nargsCount && argsToSet.length < nargsCount) ||\n        (isNaN(nargsCount) && argsToSet.length === 0)) {\n      error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    setArg(key, argsToSet)\n    return i\n  }\n\n  function setArg (key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      const alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    const value = processValue(key, val)\n    const splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        const a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        // populate alias only if is not already an alias of the full key\n        // (already populated above)\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\n          setKey(argv, x, value)\n        }\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      const keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        Object.defineProperty(argvReturn, key, {\n          enumerable: true,\n          get () {\n            return val\n          },\n          set (value) {\n            val = typeof value === 'string' ? path.normalize(value) : value\n          }\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' &&\n      (val[0] === \"'\" || val[0] === '\"') &&\n      val[val.length - 1] === val[0]\n    ) {\n      val = val.substring(1, val.length - 1)\n    }\n\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    let value = Array.isArray(val)\n      ? val.map(function (v) { return maybeCoerceNumber(key, v) })\n      : maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    const configLookup = Object.create(null)\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      const configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          let config = null\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      const value = config[key]\n      const fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    const prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        const keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    let coerce\n    const applied = new Set()\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            const value = maybeCoerceNumber(key, coerce(argv[key]))\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied.add(ali)\n              argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n        if (canLog) defaulted[key] = true\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    const key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key)\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n    const key = sanitizeKey(keys[keys.length - 1])\n\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    const isValueArray = Array.isArray(value)\n    let duplicate = configuration['duplicate-arguments-array']\n\n    // nargs has higher priority than duplicate\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n        o[key] = undefined\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(\n      o[key] === undefined ||\n        checkAllAliases(key, flags.counts) ||\n        checkAllAliases(key, flags.bools)\n    )) {\n      o[key] = [o[key], value]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases (...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            const c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            const c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // return the 1st set flag for any of a key's aliases (or false if no flag set)\n  function checkAllAliases (key, flag) {\n    const toCheck = [].concat(flags.aliases[key] || [], key)\n    const keys = Object.keys(flag)\n    const setAlias = toCheck.find(key => keys.includes(key))\n    return setAlias ? flag[setAlias] : false\n  }\n\n  function hasAnyFlag (key) {\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]))\n    return toCheck.some(function (flag) {\n      return Array.isArray(flag) ? flag.includes(key) : flag[key]\n    })\n  }\n\n  function hasFlagsMatching (arg, ...patterns) {\n    const toCheck = [].concat(...patterns)\n    return toCheck.some(function (pattern) {\n      const match = arg.match(pattern)\n      return match && hasAnyFlag(match[1])\n    })\n  }\n\n  // based on a simplified version of the short flag group parsing logic\n  function hasAllShortFlags (arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }\n    let hasAllFlags = true\n    let next\n    const letters = arg.slice(1).split('')\n    for (let j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2)\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false\n        break\n      }\n\n      if ((letters[j + 1] && letters[j + 1] === '=') ||\n        next === '-' ||\n        (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n        (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n        break\n      }\n    }\n    return hasAllFlags\n  }\n\n  function isUnknownOptionAsArg (arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg)\n  }\n\n  function isUnknownOption (arg) {\n    // ignore negative numbers\n    if (arg.match(negative)) { return false }\n    // if this is a short option group and all of them are configured, it isn't unknown\n    if (hasAllShortFlags(arg)) { return false }\n    // e.g. '--count=2'\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/\n    // e.g. '-a' or '--arg'\n    const normalFlag = /^-+([^=]+?)$/\n    // e.g. '-a-'\n    const flagEndingInHyphen = /^-+([^=]+?)-$/\n    // e.g. '-abc123'\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/\n    // e.g. '-a/usr/local'\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/\n    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)\n  }\n\n  // make a best effor to pick a default value\n  // for an option based on name and type.\n  function defaultValue (key) {\n    if (!checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts) &&\n        `${key}` in defaults) {\n      return defaults[key]\n    } else {\n      return defaultForType(guessType(key))\n    }\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    const def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key) {\n    let type = 'boolean'\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.bools)) type = 'boolean'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n    return type\n  }\n\n  function isNumber (x) {\n    if (x === null || x === undefined) return false\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number') return true\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (x.length > 1 && x[0] === '0') return false\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  // check user configuration settings for inconsistencies\n  function checkConfiguration () {\n    // count keys should not be set as array/narg\n    Object.keys(flags.counts).find(key => {\n      if (checkAllAliases(key, flags.arrays)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key))\n        return true\n      } else if (checkAllAliases(key, flags.nargs)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key))\n        return true\n      }\n    })\n  }\n\n  return {\n    argv: Object.assign(argvReturn, argv),\n    error: error,\n    aliases: Object.assign({}, flags.aliases),\n    newAliases: Object.assign({}, newAliases),\n    defaulted: Object.assign({}, defaulted),\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  const aliasArrays = []\n  const combined = Object.create(null)\n  let change = true\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  const result = parse(args.slice(), opts)\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey (key) {\n  if (key === '__proto__') return '___proto___'\n  return key\n}\n\nmodule.exports = Parser\n","// take an un-split argv string and tokenize it.\nmodule.exports = function (argString) {\n  if (Array.isArray(argString)) {\n    return argString.map(e => typeof e !== 'string' ? e + '' : e)\n  }\n\n  argString = argString.trim()\n\n  let i = 0\n  let prevC = null\n  let c = null\n  let opening = null\n  const args = []\n\n  for (let ii = 0; ii < argString.length; ii++) {\n    prevC = c\n    c = argString.charAt(ii)\n\n    // split on spaces unless we're in quotes.\n    if (c === ' ' && !opening) {\n      if (!(prevC === ' ')) {\n        i++\n      }\n      continue\n    }\n\n    // don't split the string if we're in matching\n    // opening or closing single and double quotes.\n    if (c === opening) {\n      opening = null\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c\n    }\n\n    if (!args[i]) args[i] = ''\n    args[i] += c\n  }\n\n  return args\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/yargs/build/lib sync recursive\";","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyExtends = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst yerror_1 = require(\"./yerror\");\nlet previouslyVisitedConfigs = [];\nfunction checkForCircularExtends(cfgPath) {\n    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n        throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);\n    }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n    return path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n    const target = {};\n    function isObject(obj) {\n        return obj && typeof obj === 'object' && !Array.isArray(obj);\n    }\n    Object.assign(target, config1);\n    for (const key of Object.keys(config2)) {\n        if (isObject(config2[key]) && isObject(target[key])) {\n            target[key] = mergeDeep(config1[key], config2[key]);\n        }\n        else {\n            target[key] = config2[key];\n        }\n    }\n    return target;\n}\nfunction applyExtends(config, cwd, mergeExtends = false) {\n    let defaultConfig = {};\n    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n        if (typeof config.extends !== 'string')\n            return defaultConfig;\n        const isPath = /\\.json|\\..*rc$/.test(config.extends);\n        let pathToDefault = null;\n        if (!isPath) {\n            try {\n                pathToDefault = require.resolve(config.extends);\n            }\n            catch (err) {\n                // most likely this simply isn't a module.\n            }\n        }\n        else {\n            pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n        }\n        // maybe the module uses key for some other reason,\n        // err on side of caution.\n        if (!pathToDefault && !isPath)\n            return config;\n        if (!pathToDefault)\n            throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);\n        checkForCircularExtends(pathToDefault);\n        previouslyVisitedConfigs.push(pathToDefault);\n        defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n        delete config.extends;\n        defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);\n    }\n    previouslyVisitedConfigs = [];\n    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\nexports.applyExtends = applyExtends;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argsert = void 0;\nconst yerror_1 = require(\"./yerror\");\nconst parse_command_1 = require(\"./parse-command\");\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];\n    }\n    // TODO: should this eventually raise an exception.\n    try {\n        // preface the argument description with \"cmd\", so\n        // that we can run it through yargs' command parser.\n        let position = 0;\n        let [parsed, callerArguments, length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        length = length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach((demanded) => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach((optional) => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nexports.argsert = argsert;\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new yerror_1.YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;\nconst common_types_1 = require(\"./common-types\");\nconst is_promise_1 = require(\"./is-promise\");\nconst middleware_1 = require(\"./middleware\");\nconst parse_command_1 = require(\"./parse-command\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst yargs_1 = require(\"./yargs\");\nconst requireDirectory = require(\"require-directory\");\nconst whichModule = require(\"which-module\");\nconst Parser = require(\"yargs-parser\");\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nfunction command(yargs, usage, validation, globalMiddleware = []) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            aliases = cmd.slice(1);\n            cmd = cmd[0];\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        // allow a module to be provided instead of separate builder and handler\n        if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        // parse positionals out of cmd string\n        const parsedCommand = parse_command_1.parseCommand(cmd);\n        // remove positional args from aliases only\n        aliases = aliases.map(alias => parse_command_1.parseCommand(alias).cmd);\n        // check for default and filter out '*''\n        let isDefault = false;\n        const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n            if (DEFAULT_MARKER.test(c)) {\n                isDefault = true;\n                return false;\n            }\n            return true;\n        });\n        // standardize on $0 for default command.\n        if (parsedAliases.length === 0 && isDefault)\n            parsedAliases.push('$0');\n        // shift cmd and aliases after filtering out '*'\n        if (isDefault) {\n            parsedCommand.cmd = parsedAliases[0];\n            aliases = parsedAliases.slice(1);\n            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n        }\n        // populate aliasMap\n        aliases.forEach((alias) => {\n            aliasMap[alias] = parsedCommand.cmd;\n        });\n        if (description !== false) {\n            usage.command(cmd, description, isDefault, aliases, deprecated);\n        }\n        handlers[parsedCommand.cmd] = {\n            original: cmd,\n            description,\n            handler,\n            builder: builder || {},\n            middlewares,\n            deprecated,\n            demanded: parsedCommand.demanded,\n            optional: parsedCommand.optional\n        };\n        if (isDefault)\n            defaultCommand = handlers[parsedCommand.cmd];\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        // disable recursion to support nested directories of subcommands\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        // exclude 'json', 'coffee' from require-directory defaults\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        // allow consumer to define their own visitor function\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        // call addHandler via visitor function\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            // allow consumer to skip modules with their own visitor\n            if (visited) {\n                // check for cyclic reference\n                // each command file path should only be seen once per execution\n                if (~context.files.indexOf(joined))\n                    return visited;\n                // keep track of visited files in context.files\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    // lookup module object from require()d command and derive name\n    // if module was not require()d and no name given, throw error\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    // derive command name from filename\n    function commandFromFilename(filename) {\n        return path.basename(filename, path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            common_types_1.assertNotStrictEqual(test, true);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        // what does yargs look like after the builder is run?\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            // a function can be provided, which builds\n            // up a yargs chain and possibly returns it.\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            // as a short hand, an object can instead be provided, specifying\n            // the options that a command takes.\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach((key) => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n        middleware_1.applyMiddleware(innerArgv, yargs, middlewares, true);\n        // we apply validation post-hoc, so that custom\n        // checks get passed populated positional arguments.\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            // to simplify the parsing of positionals in commands,\n            // we temporarily populate '--' rather than _, with arguments\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            if (!populateDoubleDash)\n                yargs._copyDoubleDash(innerArgv);\n            innerArgv = middleware_1.applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (is_promise_1.isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (is_promise_1.isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                        // fail's throwing would cause an unhandled rejection.\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return !yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0;\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n        const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c); });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        common_types_1.assertNotStrictEqual(defaultCommand, undefined);\n        if (shouldUpdateUsage(yargs)) {\n            // build the root-level command string from the default string.\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else {\n            Object.keys(builder).forEach((key) => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n    // onto argv.\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length); // nuke the current commands\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._);\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    // we run yargs-parser against the positional arguments\n    // applying the same parsing logic used for flags.\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        // combine the parsing hints we've inferred from the command\n        // string with explicitly configured parsing hints.\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        delete options.config; //  don't load config when processing positionals.\n        const unparsed = [];\n        Object.keys(positionalMap).forEach((key) => {\n            positionalMap[key].map((value) => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        // short-circuit parse.\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            // only copy over positional keys (don't overwrite\n            // flag arguments that were already parsed).\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach((key) => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach((key) => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    // any new aliases need to be placed in positionalMap, which\n                    // is used for validation.\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {}\n        };\n        const parsed = parse_command_1.parseCommand(cmdString);\n        parsed.demanded.forEach((d) => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach((o) => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    // used by yargs.parse() to freeze\n    // the state of commands such that\n    // we can apply .parse() multiple times\n    // with the same yargs instance.\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            handlers,\n            aliasMap,\n            defaultCommand\n        } = frozen);\n    };\n    return self;\n}\nexports.command = command;\nfunction isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object';\n}\nexports.isCommandHandlerDefinition = isCommandHandlerDefinition;\nfunction isCommandBuilderDefinition(builder) {\n    return typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function';\n}\nexports.isCommandBuilderDefinition = isCommandBuilderDefinition;\nfunction isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nexports.isCommandBuilderCallback = isCommandBuilderCallback;\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectKeys = exports.assertSingleKey = exports.assertNotStrictEqual = void 0;\nconst assert_1 = require(\"assert\");\n/**\n * Typing wrapper around assert.notStrictEqual()\n */\nfunction assertNotStrictEqual(actual, expected, message) {\n    assert_1.notStrictEqual(actual, expected, message);\n}\nexports.assertNotStrictEqual = assertNotStrictEqual;\n/**\n * Asserts actual is a single key, not a key array or a key map.\n */\nfunction assertSingleKey(actual) {\n    assert_1.strictEqual(typeof actual, 'string');\n}\nexports.assertSingleKey = assertSingleKey;\n/**\n * Typing wrapper around Object.keys()\n */\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nexports.objectKeys = objectKeys;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completionZshTemplate = exports.completionShTemplate = void 0;\nexports.completionShTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word=\"\\${COMP_WORDS[COMP_CWORD]}\"\n    args=(\"\\${COMP_WORDS[@]}\")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions \"\\${args[@]}\")\n\n    COMPREPLY=( $(compgen -W \"\\${type_list}\" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nexports.completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$'\\n' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"\\${words[@]}\"))\n  IFS=$si\n  _describe 'values' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completion = void 0;\nconst command_1 = require(\"./command\");\nconst templates = require(\"./completion-templates\");\nconst is_promise_1 = require(\"./is-promise\");\nconst parse_command_1 = require(\"./parse-command\");\nconst path = require(\"path\");\nconst common_types_1 = require(\"./common-types\");\n// add bash completions to your\n//  yargs-powered applications.\nfunction completion(yargs, usage, command) {\n    const self = {\n        completionKey: 'get-yargs-completions'\n    };\n    let aliases;\n    self.setParsed = function setParsed(parsed) {\n        aliases = parsed.aliases;\n    };\n    const zshShell = (process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1) ||\n        (process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf('zsh') !== -1);\n    // get a list of completion commands.\n    // 'args' is the array of strings from the line to be completed\n    self.getCompletion = function getCompletion(args, done) {\n        const completions = [];\n        const current = args.length ? args[args.length - 1] : '';\n        const argv = yargs.parse(args, true);\n        const parentCommands = yargs.getContext().commands;\n        // a custom completion function can be provided\n        // to completion().\n        function runCompletionFunction(argv) {\n            common_types_1.assertNotStrictEqual(completionFunction, null);\n            if (isSyncCompletionFunction(completionFunction)) {\n                const result = completionFunction(current, argv);\n                // promise based completion function.\n                if (is_promise_1.isPromise(result)) {\n                    return result.then((list) => {\n                        process.nextTick(() => { done(list); });\n                    }).catch((err) => {\n                        process.nextTick(() => { throw err; });\n                    });\n                }\n                // synchronous completion function.\n                return done(result);\n            }\n            else {\n                // asynchronous completion function\n                return completionFunction(current, argv, (completions) => {\n                    done(completions);\n                });\n            }\n        }\n        if (completionFunction) {\n            return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\n        }\n        const handlers = command.getCommandHandlers();\n        for (let i = 0, ii = args.length; i < ii; ++i) {\n            if (handlers[args[i]] && handlers[args[i]].builder) {\n                const builder = handlers[args[i]].builder;\n                if (command_1.isCommandBuilderCallback(builder)) {\n                    const y = yargs.reset();\n                    builder(y);\n                    return y.argv;\n                }\n            }\n        }\n        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n            usage.getCommands().forEach((usageCommand) => {\n                const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;\n                if (args.indexOf(commandName) === -1) {\n                    if (!zshShell) {\n                        completions.push(commandName);\n                    }\n                    else {\n                        const desc = usageCommand[1] || '';\n                        completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n                    }\n                }\n            });\n        }\n        if (current.match(/^-/) || (current === '' && completions.length === 0)) {\n            const descs = usage.getDescriptions();\n            const options = yargs.getOptions();\n            Object.keys(options.key).forEach((key) => {\n                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);\n                // If the key and its aliases aren't in 'args', add the key to 'completions'\n                let keyAndAliases = [key].concat(aliases[key] || []);\n                if (negable)\n                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n                function completeOptionKey(key) {\n                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n                    if (notInArgs) {\n                        const startsByTwoDashes = (s) => /^--/.test(s);\n                        const isShortOption = (s) => /^[^0-9]$/.test(s);\n                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n                        if (!zshShell) {\n                            completions.push(dashes + key);\n                        }\n                        else {\n                            const desc = descs[key] || '';\n                            completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n                        }\n                    }\n                }\n                completeOptionKey(key);\n                if (negable && !!options.default[key])\n                    completeOptionKey(`no-${key}`);\n            });\n        }\n        done(completions);\n    };\n    // generate the completion script to add to your .bashrc.\n    self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n        let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\n        const name = path.basename($0);\n        // add ./to applications not yet installed as bin.\n        if ($0.match(/\\.js$/))\n            $0 = `./${$0}`;\n        script = script.replace(/{{app_name}}/g, name);\n        script = script.replace(/{{completion_command}}/g, cmd);\n        return script.replace(/{{app_path}}/g, $0);\n    };\n    // register a function to perform your own custom\n    // completions., this function can be either\n    // synchrnous or asynchronous.\n    let completionFunction = null;\n    self.registerFunction = (fn) => {\n        completionFunction = fn;\n    };\n    return self;\n}\nexports.completion = completion;\nfunction isSyncCompletionFunction(completionFunction) {\n    return completionFunction.length < 3;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPromise = void 0;\nfunction isPromise(maybePromise) {\n    return !!maybePromise &&\n        !!maybePromise.then &&\n        (typeof maybePromise.then === 'function');\n}\nexports.isPromise = isPromise;\n","\"use strict\";\n/*\nCopyright (c) 2011 Andrei Mackenzie\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.levenshtein = void 0;\n// levenshtein distance algorithm, pulled from Andrei Mackenzie's MIT licensed.\n// gist, which can be found here: https://gist.github.com/andrei-m/982927\n// Compute the edit distance between the two given strings\nfunction levenshtein(a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    const matrix = [];\n    // increment along the first column of each row\n    let i;\n    for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    // increment each column in the first row\n    let j;\n    for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n    // Fill in the rest of the matrix\n    for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            }\n            else {\n                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n                Math.min(matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j] + 1)); // deletion\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n}\nexports.levenshtein = levenshtein;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyMiddleware = exports.commandMiddlewareFactory = exports.globalMiddlewareFactory = void 0;\nconst argsert_1 = require(\"./argsert\");\nconst is_promise_1 = require(\"./is-promise\");\nfunction globalMiddlewareFactory(globalMiddleware, context) {\n    return function (callback, applyBeforeValidation = false) {\n        argsert_1.argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);\n        if (Array.isArray(callback)) {\n            for (let i = 0; i < callback.length; i++) {\n                if (typeof callback[i] !== 'function') {\n                    throw Error('middleware must be a function');\n                }\n                callback[i].applyBeforeValidation = applyBeforeValidation;\n            }\n            Array.prototype.push.apply(globalMiddleware, callback);\n        }\n        else if (typeof callback === 'function') {\n            callback.applyBeforeValidation = applyBeforeValidation;\n            globalMiddleware.push(callback);\n        }\n        return context;\n    };\n}\nexports.globalMiddlewareFactory = globalMiddlewareFactory;\nfunction commandMiddlewareFactory(commandMiddleware) {\n    if (!commandMiddleware)\n        return [];\n    return commandMiddleware.map(middleware => {\n        middleware.applyBeforeValidation = false;\n        return middleware;\n    });\n}\nexports.commandMiddlewareFactory = commandMiddlewareFactory;\nfunction applyMiddleware(argv, yargs, middlewares, beforeValidation) {\n    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');\n    return middlewares\n        .reduce((acc, middleware) => {\n        if (middleware.applyBeforeValidation !== beforeValidation) {\n            return acc;\n        }\n        if (is_promise_1.isPromise(acc)) {\n            return acc\n                .then(initialObj => Promise.all([initialObj, middleware(initialObj, yargs)]))\n                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));\n        }\n        else {\n            const result = middleware(acc, yargs);\n            if (beforeValidation && is_promise_1.isPromise(result))\n                throw beforeValidationError;\n            return is_promise_1.isPromise(result)\n                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))\n                : Object.assign(acc, result);\n        }\n    }, argv);\n}\nexports.applyMiddleware = applyMiddleware;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objFilter = void 0;\nconst common_types_1 = require(\"./common-types\");\nfunction objFilter(original = {}, filter = () => true) {\n    const obj = {};\n    common_types_1.objectKeys(original).forEach((key) => {\n        if (filter(key, original[key])) {\n            obj[key] = original[key];\n        }\n    });\n    return obj;\n}\nexports.objFilter = objFilter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCommand = void 0;\nfunction parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const firstCommand = splitCommand.shift();\n    if (!firstCommand)\n        throw new Error(`No command found in: ${cmd}`);\n    const parsedCommand = {\n        cmd: firstCommand.replace(bregex, ''),\n        demanded: [],\n        optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n        let variadic = false;\n        cmd = cmd.replace(/\\s/g, '');\n        if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1)\n            variadic = true;\n        if (/^\\[/.test(cmd)) {\n            parsedCommand.optional.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n        else {\n            parsedCommand.demanded.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n    });\n    return parsedCommand;\n}\nexports.parseCommand = parseCommand;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getProcessArgvBin = exports.getProcessArgvWithoutBin = void 0;\nfunction getProcessArgvBinIndex() {\n    // The binary name is the first command line argument for:\n    // - bundled Electron apps: bin argv1 argv2 ... argvn\n    if (isBundledElectronApp())\n        return 0;\n    // or the second one (default) for:\n    // - standard node apps: node bin.js argv1 argv2 ... argvn\n    // - unbundled Electron apps: electron bin.js argv1 arg2 ... argvn\n    return 1;\n}\nfunction isBundledElectronApp() {\n    // process.defaultApp is either set by electron in an electron unbundled app, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processdefaultapp-readonly\n    return isElectronApp() && !process.defaultApp;\n}\nfunction isElectronApp() {\n    // process.versions.electron is either set by electron, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processversionselectron-readonly\n    return !!process.versions.electron;\n}\nfunction getProcessArgvWithoutBin() {\n    return process.argv.slice(getProcessArgvBinIndex() + 1);\n}\nexports.getProcessArgvWithoutBin = getProcessArgvWithoutBin;\nfunction getProcessArgvBin() {\n    return process.argv[getProcessArgvBinIndex()];\n}\nexports.getProcessArgvBin = getProcessArgvBin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.usage = void 0;\n// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst common_types_1 = require(\"./common-types\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst path = require(\"path\");\nconst yerror_1 = require(\"./yerror\");\nconst decamelize = require(\"decamelize\");\nconst setBlocking = require(\"set-blocking\");\nconst stringWidth = require(\"string-width\");\nfunction usage(yargs, y18n) {\n    const __ = y18n.__;\n    const self = {};\n    // methods for ouputting/building failure message.\n    const fails = [];\n    self.failFn = function failFn(f) {\n        fails.push(f);\n    };\n    let failMessage = null;\n    let showHelpOnFail = true;\n    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {\n        function parseFunctionArgs() {\n            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];\n        }\n        const [enabled, message] = parseFunctionArgs();\n        failMessage = message;\n        showHelpOnFail = enabled;\n        return self;\n    };\n    let failureOutput = false;\n    self.fail = function fail(msg, err) {\n        const logger = yargs._getLoggerInstance();\n        if (fails.length) {\n            for (let i = fails.length - 1; i >= 0; --i) {\n                fails[i](msg, err, self);\n            }\n        }\n        else {\n            if (yargs.getExitProcess())\n                setBlocking(true);\n            // don't output failure message more than once\n            if (!failureOutput) {\n                failureOutput = true;\n                if (showHelpOnFail) {\n                    yargs.showHelp('error');\n                    logger.error();\n                }\n                if (msg || err)\n                    logger.error(msg || err);\n                if (failMessage) {\n                    if (msg || err)\n                        logger.error('');\n                    logger.error(failMessage);\n                }\n            }\n            err = err || new yerror_1.YError(msg);\n            if (yargs.getExitProcess()) {\n                return yargs.exit(1);\n            }\n            else if (yargs._hasParseCallback()) {\n                return yargs.exit(1, err);\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    // methods for ouputting/building help (usage) message.\n    let usages = [];\n    let usageDisabled = false;\n    self.usage = (msg, description) => {\n        if (msg === null) {\n            usageDisabled = true;\n            usages = [];\n            return self;\n        }\n        usageDisabled = false;\n        usages.push([msg, description || '']);\n        return self;\n    };\n    self.getUsage = () => {\n        return usages;\n    };\n    self.getUsageDisabled = () => {\n        return usageDisabled;\n    };\n    self.getPositionalGroupName = () => {\n        return __('Positionals:');\n    };\n    let examples = [];\n    self.example = (cmd, description) => {\n        examples.push([cmd, description || '']);\n    };\n    let commands = [];\n    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {\n        // the last default wins, so cancel out any previously set default\n        if (isDefault) {\n            commands = commands.map((cmdArray) => {\n                cmdArray[2] = false;\n                return cmdArray;\n            });\n        }\n        commands.push([cmd, description || '', isDefault, aliases, deprecated]);\n    };\n    self.getCommands = () => commands;\n    let descriptions = {};\n    self.describe = function describe(keyOrKeys, desc) {\n        if (Array.isArray(keyOrKeys)) {\n            keyOrKeys.forEach((k) => {\n                self.describe(k, desc);\n            });\n        }\n        else if (typeof keyOrKeys === 'object') {\n            Object.keys(keyOrKeys).forEach((k) => {\n                self.describe(k, keyOrKeys[k]);\n            });\n        }\n        else {\n            descriptions[keyOrKeys] = desc;\n        }\n    };\n    self.getDescriptions = () => descriptions;\n    let epilogs = [];\n    self.epilog = (msg) => {\n        epilogs.push(msg);\n    };\n    let wrapSet = false;\n    let wrap;\n    self.wrap = (cols) => {\n        wrapSet = true;\n        wrap = cols;\n    };\n    function getWrap() {\n        if (!wrapSet) {\n            wrap = windowWidth();\n            wrapSet = true;\n        }\n        return wrap;\n    }\n    const deferY18nLookupPrefix = '__yargsString__:';\n    self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n    self.help = function help() {\n        if (cachedHelpMessage)\n            return cachedHelpMessage;\n        normalizeAliases();\n        // handle old demanded API\n        const base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);\n        const demandedOptions = yargs.getDemandedOptions();\n        const demandedCommands = yargs.getDemandedCommands();\n        const deprecatedOptions = yargs.getDeprecatedOptions();\n        const groups = yargs.getGroups();\n        const options = yargs.getOptions();\n        let keys = [];\n        keys = keys.concat(Object.keys(descriptions));\n        keys = keys.concat(Object.keys(demandedOptions));\n        keys = keys.concat(Object.keys(demandedCommands));\n        keys = keys.concat(Object.keys(options.default));\n        keys = keys.filter(filterHiddenOptions);\n        keys = Object.keys(keys.reduce((acc, key) => {\n            if (key !== '_')\n                acc[key] = true;\n            return acc;\n        }, {}));\n        const theWrap = getWrap();\n        const ui = require('cliui')({\n            width: theWrap,\n            wrap: !!theWrap\n        });\n        // the usage string.\n        if (!usageDisabled) {\n            if (usages.length) {\n                // user-defined usage.\n                usages.forEach((usage) => {\n                    ui.div(`${usage[0].replace(/\\$0/g, base$0)}`);\n                    if (usage[1]) {\n                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });\n                    }\n                });\n                ui.div();\n            }\n            else if (commands.length) {\n                let u = null;\n                // demonstrate how commands are used.\n                if (demandedCommands._) {\n                    u = `${base$0} <${__('command')}>\\n`;\n                }\n                else {\n                    u = `${base$0} [${__('command')}]\\n`;\n                }\n                ui.div(`${u}`);\n            }\n        }\n        // your application's commands, i.e., non-option\n        // arguments populated in '_'.\n        if (commands.length) {\n            ui.div(__('Commands:'));\n            const context = yargs.getContext();\n            const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';\n            if (yargs.getParserConfiguration()['sort-commands'] === true) {\n                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n            }\n            commands.forEach((command) => {\n                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}`; // drop $0 from default commands.\n                ui.span({\n                    text: commandString,\n                    padding: [0, 2, 0, 2],\n                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4\n                }, { text: command[1] });\n                const hints = [];\n                if (command[2])\n                    hints.push(`[${__('default')}]`);\n                if (command[3] && command[3].length) {\n                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);\n                }\n                if (command[4]) {\n                    if (typeof command[4] === 'string') {\n                        hints.push(`[${__('deprecated: %s', command[4])}]`);\n                    }\n                    else {\n                        hints.push(`[${__('deprecated')}]`);\n                    }\n                }\n                if (hints.length) {\n                    ui.div({ text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right' });\n                }\n                else {\n                    ui.div();\n                }\n            });\n            ui.div();\n        }\n        // perform some cleanup on the keys array, making it\n        // only include top-level keys not their aliases.\n        const aliasKeys = (Object.keys(options.alias) || [])\n            .concat(Object.keys(yargs.parsed.newAliases) || []);\n        keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));\n        // populate 'Options:' group with any keys that have not\n        // explicitly had a group set.\n        const defaultGroup = __('Options:');\n        if (!groups[defaultGroup])\n            groups[defaultGroup] = [];\n        addUngroupedKeys(keys, options.alias, groups, defaultGroup);\n        // display 'Options:' table along with any custom tables:\n        Object.keys(groups).forEach((groupName) => {\n            if (!groups[groupName].length)\n                return;\n            // if we've grouped the key 'f', but 'f' aliases 'foobar',\n            // normalizedKeys should contain only 'foobar'.\n            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {\n                if (~aliasKeys.indexOf(key))\n                    return key;\n                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n                    if (~(options.alias[aliasKey] || []).indexOf(key))\n                        return aliasKey;\n                }\n                return key;\n            });\n            if (normalizedKeys.length < 1)\n                return;\n            ui.div(groupName);\n            // actually generate the switches string --foo, -f, --bar.\n            const switches = normalizedKeys.reduce((acc, key) => {\n                acc[key] = [key].concat(options.alias[key] || [])\n                    .map(sw => {\n                    // for the special positional group don't\n                    // add '--' or '-' prefix.\n                    if (groupName === self.getPositionalGroupName())\n                        return sw;\n                    else {\n                        return (\n                        // matches yargs-parser logic in which single-digits\n                        // aliases declared with a boolean type are now valid\n                        /^[0-9]$/.test(sw)\n                            ? ~options.boolean.indexOf(key) ? '-' : '--'\n                            : sw.length > 1 ? '--' : '-') + sw;\n                    }\n                })\n                    .join(', ');\n                return acc;\n            }, {});\n            normalizedKeys.forEach((key) => {\n                const kswitch = switches[key];\n                let desc = descriptions[key] || '';\n                let type = null;\n                if (~desc.lastIndexOf(deferY18nLookupPrefix))\n                    desc = __(desc.substring(deferY18nLookupPrefix.length));\n                if (~options.boolean.indexOf(key))\n                    type = `[${__('boolean')}]`;\n                if (~options.count.indexOf(key))\n                    type = `[${__('count')}]`;\n                if (~options.string.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.normalize.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.array.indexOf(key))\n                    type = `[${__('array')}]`;\n                if (~options.number.indexOf(key))\n                    type = `[${__('number')}]`;\n                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'\n                    ? `[${__('deprecated: %s', deprecated)}]`\n                    : `[${__('deprecated')}]`;\n                const extra = [\n                    (key in deprecatedOptions) ? deprecatedExtra(deprecatedOptions[key]) : null,\n                    type,\n                    (key in demandedOptions) ? `[${__('required')}]` : null,\n                    options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,\n                    defaultString(options.default[key], options.defaultDescription[key])\n                ].filter(Boolean).join(' ');\n                ui.span({ text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 }, desc);\n                if (extra)\n                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });\n                else\n                    ui.div();\n            });\n            ui.div();\n        });\n        // describe some common use-cases for your application.\n        if (examples.length) {\n            ui.div(__('Examples:'));\n            examples.forEach((example) => {\n                example[0] = example[0].replace(/\\$0/g, base$0);\n            });\n            examples.forEach((example) => {\n                if (example[1] === '') {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2]\n                    });\n                }\n                else {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2],\n                        width: maxWidth(examples, theWrap) + 4\n                    }, {\n                        text: example[1]\n                    });\n                }\n            });\n            ui.div();\n        }\n        // the usage string.\n        if (epilogs.length > 0) {\n            const e = epilogs.map(epilog => epilog.replace(/\\$0/g, base$0)).join('\\n');\n            ui.div(`${e}\\n`);\n        }\n        // Remove the trailing white spaces\n        return ui.toString().replace(/\\s*$/, '');\n    };\n    // return the maximum width of a string\n    // in the left-hand column of a table.\n    function maxWidth(table, theWrap, modifier) {\n        let width = 0;\n        // table might be of the form [leftColumn],\n        // or {key: leftColumn}\n        if (!Array.isArray(table)) {\n            table = Object.values(table).map(v => [v]);\n        }\n        table.forEach((v) => {\n            width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);\n        });\n        // if we've enabled 'wrap' we should limit\n        // the max-width of the left-column.\n        if (theWrap)\n            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));\n        return width;\n    }\n    // make sure any options set for aliases,\n    // are copied to the keys being aliased.\n    function normalizeAliases() {\n        // handle old demanded API\n        const demandedOptions = yargs.getDemandedOptions();\n        const options = yargs.getOptions();\n        (Object.keys(options.alias) || []).forEach((key) => {\n            options.alias[key].forEach((alias) => {\n                // copy descriptions.\n                if (descriptions[alias])\n                    self.describe(key, descriptions[alias]);\n                // copy demanded.\n                if (alias in demandedOptions)\n                    yargs.demandOption(key, demandedOptions[alias]);\n                // type messages.\n                if (~options.boolean.indexOf(alias))\n                    yargs.boolean(key);\n                if (~options.count.indexOf(alias))\n                    yargs.count(key);\n                if (~options.string.indexOf(alias))\n                    yargs.string(key);\n                if (~options.normalize.indexOf(alias))\n                    yargs.normalize(key);\n                if (~options.array.indexOf(alias))\n                    yargs.array(key);\n                if (~options.number.indexOf(alias))\n                    yargs.number(key);\n            });\n        });\n    }\n    // if yargs is executing an async handler, we take a snapshot of the\n    // help message to display on failure:\n    let cachedHelpMessage;\n    self.cacheHelpMessage = function () {\n        cachedHelpMessage = this.help();\n    };\n    // however this snapshot must be cleared afterwards\n    // not to be be used by next calls to parse\n    self.clearCachedHelpMessage = function () {\n        cachedHelpMessage = undefined;\n    };\n    // given a set of keys, place any keys that are\n    // ungrouped under the 'Options:' grouping.\n    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {\n        let groupedKeys = [];\n        let toCheck = null;\n        Object.keys(groups).forEach((group) => {\n            groupedKeys = groupedKeys.concat(groups[group]);\n        });\n        keys.forEach((key) => {\n            toCheck = [key].concat(aliases[key]);\n            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n                groups[defaultGroup].push(key);\n            }\n        });\n        return groupedKeys;\n    }\n    function filterHiddenOptions(key) {\n        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];\n    }\n    self.showHelp = (level) => {\n        const logger = yargs._getLoggerInstance();\n        if (!level)\n            level = 'error';\n        const emit = typeof level === 'function' ? level : logger[level];\n        emit(self.help());\n    };\n    self.functionDescription = (fn) => {\n        const description = fn.name ? decamelize(fn.name, '-') : __('generated-value');\n        return ['(', description, ')'].join('');\n    };\n    self.stringifiedValues = function stringifiedValues(values, separator) {\n        let string = '';\n        const sep = separator || ', ';\n        const array = [].concat(values);\n        if (!values || !array.length)\n            return string;\n        array.forEach((value) => {\n            if (string.length)\n                string += sep;\n            string += JSON.stringify(value);\n        });\n        return string;\n    };\n    // format the default-value-string displayed in\n    // the right-hand column.\n    function defaultString(value, defaultDescription) {\n        let string = `[${__('default:')} `;\n        if (value === undefined && !defaultDescription)\n            return null;\n        if (defaultDescription) {\n            string += defaultDescription;\n        }\n        else {\n            switch (typeof value) {\n                case 'string':\n                    string += `\"${value}\"`;\n                    break;\n                case 'object':\n                    string += JSON.stringify(value);\n                    break;\n                default:\n                    string += value;\n            }\n        }\n        return `${string}]`;\n    }\n    // guess the width of the console window, max-width 80.\n    function windowWidth() {\n        const maxWidth = 80;\n        // CI is not a TTY\n        /* c8 ignore next 2 */\n        if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n            return Math.min(maxWidth, process.stdout.columns);\n        }\n        else {\n            return maxWidth;\n        }\n    }\n    // logic for displaying application version.\n    let version = null;\n    self.version = (ver) => {\n        version = ver;\n    };\n    self.showVersion = () => {\n        const logger = yargs._getLoggerInstance();\n        logger.log(version);\n    };\n    self.reset = function reset(localLookup) {\n        // do not reset wrap here\n        // do not reset fails here\n        failMessage = null;\n        failureOutput = false;\n        usages = [];\n        usageDisabled = false;\n        epilogs = [];\n        examples = [];\n        commands = [];\n        descriptions = obj_filter_1.objFilter(descriptions, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        } = frozen);\n    };\n    return self;\n}\nexports.usage = usage;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validation = void 0;\nconst argsert_1 = require(\"./argsert\");\nconst common_types_1 = require(\"./common-types\");\nconst levenshtein_1 = require(\"./levenshtein\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst specialKeys = ['$0', '--', '_'];\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nfunction validation(yargs, usage, y18n) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    // validate appropriate # of non-option\n    // arguments were provided, i.e., '_'.\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        // don't count currently executing commands\n        const _s = argv._.length - yargs.getContext().commands.length;\n        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));\n                }\n            }\n        }\n    };\n    // validate the appropriate # of <required>\n    // positional arguments were provided:\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));\n        }\n    };\n    // make sure all the required arguments are present.\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    // check for unknown arguments (strict-mode).\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0) || isDefaultCommand) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0)) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // check for a key that is not an alias, or for which every alias is new,\n    // implying that it was invented by the parser, e.g., during camelization\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // validate arguments limited to enumerated choices\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach((value) => {\n                    // TODO case-insensitive configurability\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach((key) => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    // custom checks, added using the `check` option on yargs.\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    // check implications, argument foo implies => argument bar.\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.implies(key, i));\n            }\n            else {\n                common_types_1.assertNotStrictEqual(value, undefined);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        // convert string '1' to number 1\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            // check length of argv._\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            // check if key/value doesn't exist\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            // check if key/value exists\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach((key) => {\n            const origKey = key;\n            (implied[key] || []).forEach((value) => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach((value) => {\n                msg += (value);\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach((key) => {\n            if (conflicting[key]) {\n                conflicting[key].forEach((value) => {\n                    // we default keys to 'undefined' that have been configured, we should not\n                    // apply conflicting check unless they are a value other than 'undefined'.\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3; // if it takes more than three edits, let's move on.\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = levenshtein_1.levenshtein(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = obj_filter_1.objFilter(implied, k => !localLookup[k]);\n        conflicting = obj_filter_1.objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            implied,\n            checks,\n            conflicting\n        } = frozen);\n    };\n    return self;\n}\nexports.validation = validation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isYargsInstance = exports.rebase = exports.Yargs = void 0;\nconst command_1 = require(\"./command\");\nconst common_types_1 = require(\"./common-types\");\nconst yerror_1 = require(\"./yerror\");\nconst usage_1 = require(\"./usage\");\nconst argsert_1 = require(\"./argsert\");\nconst fs = require(\"fs\");\nconst completion_1 = require(\"./completion\");\nconst path = require(\"path\");\nconst validation_1 = require(\"./validation\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst apply_extends_1 = require(\"./apply-extends\");\nconst middleware_1 = require(\"./middleware\");\nconst processArgv = require(\"./process-argv\");\nconst is_promise_1 = require(\"./is-promise\");\nconst Parser = require(\"yargs-parser\");\nconst y18nFactory = require(\"y18n\");\nconst setBlocking = require(\"set-blocking\");\nconst findUp = require(\"find-up\");\nconst requireMainFilename = require(\"require-main-filename\");\nfunction Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {\n    const self = {};\n    let command;\n    let completion = null;\n    let groups = {};\n    const globalMiddleware = [];\n    let output = '';\n    const preservedGroups = {};\n    let usage;\n    let validation;\n    let handlerFinishCommand = null;\n    const y18n = y18nFactory({\n        directory: path.resolve(__dirname, '../../locales'),\n        updateFiles: false\n    });\n    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);\n    self.scriptName = function (scriptName) {\n        self.customScriptName = true;\n        self.$0 = scriptName;\n        return self;\n    };\n    // ignore the node bin, specify this in your\n    // bin file with #!/usr/bin/env node\n    let default$0;\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n        default$0 = process.argv.slice(1, 2);\n    }\n    else {\n        default$0 = process.argv.slice(0, 1);\n    }\n    self.$0 = default$0\n        .map(x => {\n        const b = rebase(cwd, x);\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n    })\n        .join(' ').trim();\n    if (process.env._ !== undefined && processArgv.getProcessArgvBin() === process.env._) {\n        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, '');\n    }\n    // use context object to keep track of resets, subcommand execution, etc\n    // submodules should modify and check the state of context as necessary\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\n    self.getContext = () => context;\n    // puts yargs back into an initial state. any keys\n    // that have been set to \"global\" will not be reset\n    // by this action.\n    let options;\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n        context.resets++;\n        options = options || {};\n        // put yargs back into an initial state, this\n        // logic is used to build a nested command\n        // hierarchy.\n        const tmpOptions = {};\n        tmpOptions.local = options.local ? options.local : [];\n        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n        // if a key has been explicitly set as local,\n        // we should reset it before passing options to command.\n        const localLookup = {};\n        tmpOptions.local.forEach((l) => {\n            localLookup[l] = true;\n            (aliases[l] || []).forEach((a) => {\n                localLookup[a] = true;\n            });\n        });\n        // add all groups not set to local to preserved groups\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n            const keys = groups[groupName].filter(key => !(key in localLookup));\n            if (keys.length > 0) {\n                acc[groupName] = keys;\n            }\n            return acc;\n        }, {}));\n        // groups can now be reset\n        groups = {};\n        const arrayOptions = [\n            'array', 'boolean', 'string', 'skipValidation',\n            'count', 'normalize', 'number',\n            'hiddenOptions'\n        ];\n        const objectOptions = [\n            'narg', 'key', 'alias', 'default', 'defaultDescription',\n            'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce',\n            'deprecatedOptions'\n        ];\n        arrayOptions.forEach(k => {\n            tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n        });\n        objectOptions.forEach((k) => {\n            tmpOptions[k] = obj_filter_1.objFilter(options[k], k => !localLookup[k]);\n        });\n        tmpOptions.envPrefix = options.envPrefix;\n        options = tmpOptions;\n        // if this is the first time being executed, create\n        // instances of all our helpers -- otherwise just reset.\n        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);\n        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);\n        command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);\n        if (!completion)\n            completion = completion_1.completion(self, usage, command);\n        completionCommand = null;\n        output = '';\n        exitError = null;\n        hasOutput = false;\n        self.parsed = false;\n        return self;\n    };\n    self.resetOptions();\n    // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n    const frozens = [];\n    function freeze() {\n        frozens.push({\n            options,\n            configObjects: options.configObjects.slice(0),\n            exitProcess,\n            groups,\n            strict,\n            strictCommands,\n            completionCommand,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        });\n        usage.freeze();\n        validation.freeze();\n        command.freeze();\n    }\n    function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        let configObjects;\n        ({\n            options,\n            configObjects,\n            exitProcess,\n            groups,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            strict,\n            strictCommands,\n            completionCommand,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        } = frozen);\n        options.configObjects = configObjects;\n        usage.unfreeze();\n        validation.unfreeze();\n        command.unfreeze();\n    }\n    self.boolean = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('boolean', keys);\n        return self;\n    };\n    self.array = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('array', keys);\n        return self;\n    };\n    self.number = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('number', keys);\n        return self;\n    };\n    self.normalize = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('normalize', keys);\n        return self;\n    };\n    self.count = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('count', keys);\n        return self;\n    };\n    self.string = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('string', keys);\n        return self;\n    };\n    self.requiresArg = function (keys) {\n        // the 2nd paramter [number] in the argsert the assertion is mandatory\n        // as populateParserHintSingleValueDictionary recursively calls requiresArg\n        // with Nan as a 2nd parameter, although we ignore it\n        argsert_1.argsert('<array|string|object> [number]', [keys], arguments.length);\n        // If someone configures nargs at the same time as requiresArg,\n        // nargs should take precedent,\n        // see: https://github.com/yargs/yargs/pull/1572\n        // TODO: make this work with aliases, using a check similar to\n        // checkAllAliases() in yargs-parser.\n        if (typeof keys === 'string' && options.narg[keys]) {\n            return self;\n        }\n        else {\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n        }\n        return self;\n    };\n    self.skipValidation = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('skipValidation', keys);\n        return self;\n    };\n    function populateParserHintArray(type, keys) {\n        keys = [].concat(keys);\n        keys.forEach((key) => {\n            key = sanitizeKey(key);\n            options[type].push(key);\n        });\n    }\n    self.nargs = function (key, value) {\n        argsert_1.argsert('<string|object|array> [number]', [key, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n        return self;\n    };\n    self.choices = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n        return self;\n    };\n    self.alias = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n        return self;\n    };\n    // TODO: actually deprecate self.defaults.\n    self.default = self.defaults = function (key, value, defaultDescription) {\n        argsert_1.argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n        if (defaultDescription) {\n            common_types_1.assertSingleKey(key);\n            options.defaultDescription[key] = defaultDescription;\n        }\n        if (typeof value === 'function') {\n            common_types_1.assertSingleKey(key);\n            if (!options.defaultDescription[key])\n                options.defaultDescription[key] = usage.functionDescription(value);\n            value = value.call();\n        }\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n        return self;\n    };\n    self.describe = function (key, desc) {\n        argsert_1.argsert('<object|string|array> [string]', [key, desc], arguments.length);\n        setKey(key, true);\n        usage.describe(key, desc);\n        return self;\n    };\n    function setKey(key, set) {\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n        return self;\n    }\n    function demandOption(keys, msg) {\n        argsert_1.argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n        return self;\n    }\n    self.demandOption = demandOption;\n    self.coerce = function (keys, value) {\n        argsert_1.argsert('<object|string|array> [function]', [keys, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n        return self;\n    };\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = value;\n        });\n    }\n    function populateParserHintArrayDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = (options[type][key] || []).concat(value);\n        });\n    }\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n        if (Array.isArray(key)) {\n            // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n            key.forEach((k) => {\n                builder(k, value);\n            });\n        }\n        else if (((key) => typeof key === 'object')(key)) {\n            // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n            for (const k of common_types_1.objectKeys(key)) {\n                builder(k, key[k]);\n            }\n        }\n        else {\n            singleKeyHandler(type, sanitizeKey(key), value);\n        }\n    }\n    function sanitizeKey(key) {\n        if (key === '__proto__')\n            return '___proto___';\n        return key;\n    }\n    function deleteFromParserHintObject(optionKey) {\n        // delete from all parsing hints:\n        // boolean, array, key, alias, etc.\n        common_types_1.objectKeys(options).forEach((hintKey) => {\n            // configObjects is not a parsing hint array\n            if (((key) => key === 'configObjects')(hintKey))\n                return;\n            const hint = options[hintKey];\n            if (Array.isArray(hint)) {\n                if (~hint.indexOf(optionKey))\n                    hint.splice(hint.indexOf(optionKey), 1);\n            }\n            else if (typeof hint === 'object') {\n                delete hint[optionKey];\n            }\n        });\n        // now delete the description from usage.js.\n        delete usage.getDescriptions()[optionKey];\n    }\n    self.config = function config(key = 'config', msg, parseFn) {\n        argsert_1.argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n        // allow a config object to be provided directly.\n        if ((typeof key === 'object') && !Array.isArray(key)) {\n            key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(key);\n            return self;\n        }\n        // allow for a custom parsing function.\n        if (typeof msg === 'function') {\n            parseFn = msg;\n            msg = undefined;\n        }\n        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n        (Array.isArray(key) ? key : [key]).forEach((k) => {\n            options.config[k] = parseFn || true;\n        });\n        return self;\n    };\n    self.example = function (cmd, description) {\n        argsert_1.argsert('<string|array> [string]', [cmd, description], arguments.length);\n        if (Array.isArray(cmd)) {\n            cmd.forEach((exampleParams) => self.example(...exampleParams));\n        }\n        else {\n            usage.example(cmd, description);\n        }\n        return self;\n    };\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n        argsert_1.argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n        return self;\n    };\n    self.commandDir = function (dir, opts) {\n        argsert_1.argsert('<string> [object]', [dir, opts], arguments.length);\n        const req = parentRequire || require;\n        command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n        return self;\n    };\n    // TODO: deprecate self.demand in favor of\n    // .demandCommand() .demandOption().\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\n        // you can optionally provide a 'max' key,\n        // which will raise an exception if too many '_'\n        // options are provided.\n        if (Array.isArray(max)) {\n            max.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n            max = Infinity;\n        }\n        else if (typeof max !== 'number') {\n            msg = max;\n            max = Infinity;\n        }\n        if (typeof keys === 'number') {\n            common_types_1.assertNotStrictEqual(msg, true);\n            self.demandCommand(keys, max, msg, msg);\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n        }\n        else {\n            if (typeof msg === 'string') {\n                demandOption(keys, msg);\n            }\n            else if (msg === true || typeof msg === 'undefined') {\n                demandOption(keys);\n            }\n        }\n        return self;\n    };\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n        argsert_1.argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n        if (typeof max !== 'number') {\n            minMsg = max;\n            max = Infinity;\n        }\n        self.global('_', false);\n        options.demandedCommands._ = {\n            min,\n            max,\n            minMsg,\n            maxMsg\n        };\n        return self;\n    };\n    self.getDemandedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedOptions;\n    };\n    self.getDemandedCommands = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedCommands;\n    };\n    self.deprecateOption = function deprecateOption(option, message) {\n        argsert_1.argsert('<string> [string|boolean]', [option, message], arguments.length);\n        options.deprecatedOptions[option] = message;\n        return self;\n    };\n    self.getDeprecatedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.deprecatedOptions;\n    };\n    self.implies = function (key, value) {\n        argsert_1.argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n        validation.implies(key, value);\n        return self;\n    };\n    self.conflicts = function (key1, key2) {\n        argsert_1.argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n        validation.conflicts(key1, key2);\n        return self;\n    };\n    self.usage = function (msg, description, builder, handler) {\n        argsert_1.argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n        if (description !== undefined) {\n            common_types_1.assertNotStrictEqual(msg, null);\n            // .usage() can be used as an alias for defining\n            // a default command.\n            if ((msg || '').match(/^\\$0( |$)/)) {\n                return self.command(msg, description, builder, handler);\n            }\n            else {\n                throw new yerror_1.YError('.usage() description must start with $0 if being used as alias for .command()');\n            }\n        }\n        else {\n            usage.usage(msg);\n            return self;\n        }\n    };\n    self.epilogue = self.epilog = function (msg) {\n        argsert_1.argsert('<string>', [msg], arguments.length);\n        usage.epilog(msg);\n        return self;\n    };\n    self.fail = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        usage.failFn(f);\n        return self;\n    };\n    self.onFinishCommand = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        handlerFinishCommand = f;\n        return self;\n    };\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\n    self.check = function (f, _global) {\n        argsert_1.argsert('<function> [boolean]', [f, _global], arguments.length);\n        validation.check(f, _global !== false);\n        return self;\n    };\n    self.global = function global(globals, global) {\n        argsert_1.argsert('<string|array> [boolean]', [globals, global], arguments.length);\n        globals = [].concat(globals);\n        if (global !== false) {\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\n        }\n        else {\n            globals.forEach((g) => {\n                if (options.local.indexOf(g) === -1)\n                    options.local.push(g);\n            });\n        }\n        return self;\n    };\n    self.pkgConf = function pkgConf(key, rootPath) {\n        argsert_1.argsert('<string> [string]', [key, rootPath], arguments.length);\n        let conf = null;\n        // prefer cwd to require-main-filename in this method\n        // since we're looking for e.g. \"nyc\" config in nyc consumer\n        // rather than \"yargs\" config in nyc (where nyc is the main filename)\n        const obj = pkgUp(rootPath || cwd);\n        // If an object exists in the key, add it to options.configObjects\n        if (obj[key] && typeof obj[key] === 'object') {\n            conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(conf);\n        }\n        return self;\n    };\n    const pkgs = {};\n    function pkgUp(rootPath) {\n        const npath = rootPath || '*';\n        if (pkgs[npath])\n            return pkgs[npath];\n        let obj = {};\n        try {\n            let startDir = rootPath || requireMainFilename(parentRequire);\n            // When called in an environment that lacks require.main.filename, such as a jest test runner,\n            // startDir is already process.cwd(), and should not be shortened.\n            // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n            if (!rootPath && path.extname(startDir)) {\n                startDir = path.dirname(startDir);\n            }\n            const pkgJsonPath = findUp.sync('package.json', {\n                cwd: startDir\n            });\n            common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);\n            obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());\n        }\n        catch (noop) { }\n        pkgs[npath] = obj || {};\n        return pkgs[npath];\n    }\n    let parseFn = null;\n    let parseContext = null;\n    self.parse = function parse(args, shortCircuit, _parseFn) {\n        argsert_1.argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n        freeze();\n        if (typeof args === 'undefined') {\n            const argv = self._parseArgs(processArgs);\n            const tmpParsed = self.parsed;\n            unfreeze();\n            // TODO: remove this compatibility hack when we release yargs@15.x:\n            self.parsed = tmpParsed;\n            return argv;\n        }\n        // a context object can optionally be provided, this allows\n        // additional information to be passed to a command handler.\n        if (typeof shortCircuit === 'object') {\n            parseContext = shortCircuit;\n            shortCircuit = _parseFn;\n        }\n        // by providing a function as a second argument to\n        // parse you can capture output that would otherwise\n        // default to printing to stdout/stderr.\n        if (typeof shortCircuit === 'function') {\n            parseFn = shortCircuit;\n            shortCircuit = false;\n        }\n        // completion short-circuits the parsing process,\n        // skipping validation, etc.\n        if (!shortCircuit)\n            processArgs = args;\n        if (parseFn)\n            exitProcess = false;\n        const parsed = self._parseArgs(args, !!shortCircuit);\n        completion.setParsed(self.parsed);\n        if (parseFn)\n            parseFn(exitError, parsed, output);\n        unfreeze();\n        return parsed;\n    };\n    self._getParseContext = () => parseContext || {};\n    self._hasParseCallback = () => !!parseFn;\n    self.option = self.options = function option(key, opt) {\n        argsert_1.argsert('<string|object> [object]', [key, opt], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (typeof opt !== 'object') {\n                opt = {};\n            }\n            options.key[key] = true; // track manually set keys.\n            if (opt.alias)\n                self.alias(key, opt.alias);\n            const deprecate = opt.deprecate || opt.deprecated;\n            if (deprecate) {\n                self.deprecateOption(key, deprecate);\n            }\n            const demand = opt.demand || opt.required || opt.require;\n            // A required option can be specified via \"demand: true\".\n            if (demand) {\n                self.demand(key, demand);\n            }\n            if (opt.demandOption) {\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n            }\n            if (opt.conflicts) {\n                self.conflicts(key, opt.conflicts);\n            }\n            if ('default' in opt) {\n                self.default(key, opt.default);\n            }\n            if (opt.implies !== undefined) {\n                self.implies(key, opt.implies);\n            }\n            if (opt.nargs !== undefined) {\n                self.nargs(key, opt.nargs);\n            }\n            if (opt.config) {\n                self.config(key, opt.configParser);\n            }\n            if (opt.normalize) {\n                self.normalize(key);\n            }\n            if (opt.choices) {\n                self.choices(key, opt.choices);\n            }\n            if (opt.coerce) {\n                self.coerce(key, opt.coerce);\n            }\n            if (opt.group) {\n                self.group(key, opt.group);\n            }\n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n                if (opt.alias)\n                    self.boolean(opt.alias);\n            }\n            if (opt.array || opt.type === 'array') {\n                self.array(key);\n                if (opt.alias)\n                    self.array(opt.alias);\n            }\n            if (opt.number || opt.type === 'number') {\n                self.number(key);\n                if (opt.alias)\n                    self.number(opt.alias);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n                if (opt.alias)\n                    self.string(opt.alias);\n            }\n            if (opt.count || opt.type === 'count') {\n                self.count(key);\n            }\n            if (typeof opt.global === 'boolean') {\n                self.global(key, opt.global);\n            }\n            if (opt.defaultDescription) {\n                options.defaultDescription[key] = opt.defaultDescription;\n            }\n            if (opt.skipValidation) {\n                self.skipValidation(key);\n            }\n            const desc = opt.describe || opt.description || opt.desc;\n            self.describe(key, desc);\n            if (opt.hidden) {\n                self.hide(key);\n            }\n            if (opt.requiresArg) {\n                self.requiresArg(key);\n            }\n        }\n        return self;\n    };\n    self.getOptions = () => options;\n    self.positional = function (key, opts) {\n        argsert_1.argsert('<string> <object>', [key, opts], arguments.length);\n        if (context.resets === 0) {\n            throw new yerror_1.YError(\".positional() can only be called in a command's builder function\");\n        }\n        // .positional() only supports a subset of the configuration\n        // options available to .option().\n        const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',\n            'choices', 'conflicts', 'coerce', 'type', 'describe',\n            'desc', 'description', 'alias'];\n        opts = obj_filter_1.objFilter(opts, (k, v) => {\n            let accept = supportedOpts.indexOf(k) !== -1;\n            // type can be one of string|number|boolean.\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\n                accept = false;\n            return accept;\n        });\n        // copy over any settings that can be inferred from the command string.\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n        const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n            array: [],\n            alias: {},\n            default: {},\n            demand: {}\n        };\n        common_types_1.objectKeys(parseOptions).forEach((pk) => {\n            const parseOption = parseOptions[pk];\n            if (Array.isArray(parseOption)) {\n                if (parseOption.indexOf(key) !== -1)\n                    opts[pk] = true;\n            }\n            else {\n                if (parseOption[key] && !(pk in opts))\n                    opts[pk] = parseOption[key];\n            }\n        });\n        self.group(key, usage.getPositionalGroupName());\n        return self.option(key, opts);\n    };\n    self.group = function group(opts, groupName) {\n        argsert_1.argsert('<string|array> <string>', [opts, groupName], arguments.length);\n        const existing = preservedGroups[groupName] || groups[groupName];\n        if (preservedGroups[groupName]) {\n            // we now only need to track this group name in groups.\n            delete preservedGroups[groupName];\n        }\n        const seen = {};\n        groups[groupName] = (existing || []).concat(opts).filter((key) => {\n            if (seen[key])\n                return false;\n            return (seen[key] = true);\n        });\n        return self;\n    };\n    // combine explicit and preserved groups. explicit groups should be first\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\n    // as long as options.envPrefix is not undefined,\n    // parser will apply env vars matching prefix to argv\n    self.env = function (prefix) {\n        argsert_1.argsert('[string|boolean]', [prefix], arguments.length);\n        if (prefix === false)\n            delete options.envPrefix;\n        else\n            options.envPrefix = prefix || '';\n        return self;\n    };\n    self.wrap = function (cols) {\n        argsert_1.argsert('<number|null|undefined>', [cols], arguments.length);\n        usage.wrap(cols);\n        return self;\n    };\n    let strict = false;\n    self.strict = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strict = enabled !== false;\n        return self;\n    };\n    self.getStrict = () => strict;\n    let strictCommands = false;\n    self.strictCommands = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strictCommands = enabled !== false;\n        return self;\n    };\n    self.getStrictCommands = () => strictCommands;\n    let parserConfig = {};\n    self.parserConfiguration = function parserConfiguration(config) {\n        argsert_1.argsert('<object>', [config], arguments.length);\n        parserConfig = config;\n        return self;\n    };\n    self.getParserConfiguration = () => parserConfig;\n    self.showHelp = function (level) {\n        argsert_1.argsert('[string|function]', [level], arguments.length);\n        if (!self.parsed)\n            self._parseArgs(processArgs); // run parser, if it has not already been executed.\n        if (command.hasDefaultCommand()) {\n            context.resets++; // override the restriction on top-level positoinals.\n            command.runDefaultBuilderOn(self);\n        }\n        usage.showHelp(level);\n        return self;\n    };\n    let versionOpt = null;\n    self.version = function version(opt, msg, ver) {\n        const defaultVersionOpt = 'version';\n        argsert_1.argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n        // nuke the key previously configured\n        // to return version #.\n        if (versionOpt) {\n            deleteFromParserHintObject(versionOpt);\n            usage.version(undefined);\n            versionOpt = null;\n        }\n        if (arguments.length === 0) {\n            ver = guessVersion();\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 1) {\n            if (opt === false) { // disable default 'version' key.\n                return self;\n            }\n            ver = opt;\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 2) {\n            ver = msg;\n            msg = undefined;\n        }\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n        msg = msg || usage.deferY18nLookup('Show version number');\n        usage.version(ver || undefined);\n        self.boolean(versionOpt);\n        self.describe(versionOpt, msg);\n        return self;\n    };\n    function guessVersion() {\n        const obj = pkgUp();\n        return obj.version || 'unknown';\n    }\n    let helpOpt = null;\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n        const defaultHelpOpt = 'help';\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        // nuke the key previously configured\n        // to return help.\n        if (helpOpt) {\n            deleteFromParserHintObject(helpOpt);\n            helpOpt = null;\n        }\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        // use arguments, fallback to defaults for opt and msg\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n        self.boolean(helpOpt);\n        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n        return self;\n    };\n    const defaultShowHiddenOpt = 'show-hidden';\n    options.showHiddenOpt = defaultShowHiddenOpt;\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n        self.boolean(showHiddenOpt);\n        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n        options.showHiddenOpt = showHiddenOpt;\n        return self;\n    };\n    self.hide = function hide(key) {\n        argsert_1.argsert('<string>', [key], arguments.length);\n        options.hiddenOptions.push(key);\n        return self;\n    };\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n        argsert_1.argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n        usage.showHelpOnFail(enabled, message);\n        return self;\n    };\n    var exitProcess = true;\n    self.exitProcess = function (enabled = true) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        exitProcess = enabled;\n        return self;\n    };\n    self.getExitProcess = () => exitProcess;\n    var completionCommand = null;\n    self.completion = function (cmd, desc, fn) {\n        argsert_1.argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n        // a function to execute when generating\n        // completions can be provided as the second\n        // or third argument to completion.\n        if (typeof desc === 'function') {\n            fn = desc;\n            desc = undefined;\n        }\n        // register the completion command.\n        completionCommand = cmd || completionCommand || 'completion';\n        if (!desc && desc !== false) {\n            desc = 'generate completion script';\n        }\n        self.command(completionCommand, desc);\n        // a function can be provided\n        if (fn)\n            completion.registerFunction(fn);\n        return self;\n    };\n    self.showCompletionScript = function ($0, cmd) {\n        argsert_1.argsert('[string] [string]', [$0, cmd], arguments.length);\n        $0 = $0 || self.$0;\n        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n        return self;\n    };\n    self.getCompletion = function (args, done) {\n        argsert_1.argsert('<array> <function>', [args, done], arguments.length);\n        completion.getCompletion(args, done);\n    };\n    self.locale = function (locale) {\n        argsert_1.argsert('[string]', [locale], arguments.length);\n        if (!locale) {\n            guessLocale();\n            return y18n.getLocale();\n        }\n        detectLocale = false;\n        y18n.setLocale(locale);\n        return self;\n    };\n    self.updateStrings = self.updateLocale = function (obj) {\n        argsert_1.argsert('<object>', [obj], arguments.length);\n        detectLocale = false;\n        y18n.updateLocale(obj);\n        return self;\n    };\n    let detectLocale = true;\n    self.detectLocale = function (detect) {\n        argsert_1.argsert('<boolean>', [detect], arguments.length);\n        detectLocale = detect;\n        return self;\n    };\n    self.getDetectLocale = () => detectLocale;\n    var hasOutput = false;\n    var exitError = null;\n    // maybe exit, always capture\n    // context about why we wanted to exit.\n    self.exit = (code, err) => {\n        hasOutput = true;\n        exitError = err;\n        if (exitProcess)\n            process.exit(code);\n    };\n    // we use a custom logger that buffers output,\n    // so that we can print to non-CLIs, e.g., chat-bots.\n    const _logger = {\n        log(...args) {\n            if (!self._hasParseCallback())\n                console.log(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n        error(...args) {\n            if (!self._hasParseCallback())\n                console.error(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        }\n    };\n    self._getLoggerInstance = () => _logger;\n    // has yargs output an error our help\n    // message in the current execution context.\n    self._hasOutput = () => hasOutput;\n    self._setHasOutput = () => {\n        hasOutput = true;\n    };\n    let recommendCommands;\n    self.recommendCommands = function (recommend = true) {\n        argsert_1.argsert('[boolean]', [recommend], arguments.length);\n        recommendCommands = recommend;\n        return self;\n    };\n    self.getUsageInstance = () => usage;\n    self.getValidationInstance = () => validation;\n    self.getCommandInstance = () => command;\n    self.terminalWidth = () => {\n        argsert_1.argsert([], 0);\n        return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n    };\n    Object.defineProperty(self, 'argv', {\n        get: () => self._parseArgs(processArgs),\n        enumerable: true\n    });\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n        let skipValidation = !!_calledFromCommand;\n        args = args || processArgs;\n        options.__ = y18n.__;\n        options.configuration = self.getParserConfiguration();\n        const populateDoubleDash = !!options.configuration['populate--'];\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(args, Object.assign({}, options, {\n            configuration: config\n        }));\n        let argv = parsed.argv;\n        if (parseContext)\n            argv = Object.assign({}, argv, parseContext);\n        const aliases = parsed.aliases;\n        argv.$0 = self.$0;\n        self.parsed = parsed;\n        try {\n            guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n            // while building up the argv object, there\n            // are two passes through the parser. If completion\n            // is being performed short-circuit on the first pass.\n            if (shortCircuit) {\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // if there's a handler associated with a\n            // command defer processing to it.\n            if (helpOpt) {\n                // consider any multi-char helpOpt alias as a valid help command\n                // unless all helpOpt aliases are single-char\n                // note that parsed.aliases is a normalized bidirectional map :)\n                const helpCmds = [helpOpt]\n                    .concat(aliases[helpOpt] || [])\n                    .filter(k => k.length > 1);\n                // check if help should trigger and strip it from _.\n                if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n                    argv._.pop();\n                    argv[helpOpt] = true;\n                }\n            }\n            const handlerKeys = command.getCommands();\n            const requestCompletions = completion.completionKey in argv;\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\n            const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n            if (argv._.length) {\n                if (handlerKeys.length) {\n                    let firstUnknownCommand;\n                    for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\n                        cmd = String(argv._[i]);\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n                            // commands are executed using a recursive algorithm that executes\n                            // the deepest command first; we keep track of the position in the\n                            // argv._ array that is currently being executed.\n                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n                            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                        }\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\n                            firstUnknownCommand = cmd;\n                            break;\n                        }\n                    }\n                    // run the default command, if defined\n                    if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                        const innerArgv = command.runCommand(null, self, parsed);\n                        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                    }\n                    // recommend a command if recommendCommands() has\n                    // been enabled, and no commands were found to execute\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n                        validation.recommendCommands(firstUnknownCommand, handlerKeys);\n                    }\n                }\n                // generate a completion script for adding to ~/.bashrc.\n                if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n                    if (exitProcess)\n                        setBlocking(true);\n                    self.showCompletionScript();\n                    self.exit(0);\n                }\n            }\n            else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                const innerArgv = command.runCommand(null, self, parsed);\n                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n            }\n            // we must run completions first, a user might\n            // want to complete the --help or --version option.\n            if (requestCompletions) {\n                if (exitProcess)\n                    setBlocking(true);\n                // we allow for asynchronous completions,\n                // e.g., loading in a list of commands from an API.\n                args = [].concat(args);\n                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n                completion.getCompletion(completionArgs, (completions) => {\n                    ;\n                    (completions || []).forEach((completion) => {\n                        _logger.log(completion);\n                    });\n                    self.exit(0);\n                });\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // Handle 'help' and 'version' options\n            // if we haven't already output help!\n            if (!hasOutput) {\n                Object.keys(argv).forEach((key) => {\n                    if (key === helpOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        self.showHelp('log');\n                        self.exit(0);\n                    }\n                    else if (key === versionOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        usage.showVersion();\n                        self.exit(0);\n                    }\n                });\n            }\n            // Check if any of the options to skip validation were provided\n            if (!skipValidation && options.skipValidation.length > 0) {\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n            }\n            // If the help or version options where used and exitProcess is false,\n            // or if explicitly skipped, we won't run validations.\n            if (!skipValidation) {\n                if (parsed.error)\n                    throw new yerror_1.YError(parsed.error.message);\n                // if we're executed via bash completion, don't\n                // bother with validation.\n                if (!requestCompletions) {\n                    self._runValidation(argv, aliases, {}, parsed.error);\n                }\n            }\n        }\n        catch (err) {\n            if (err instanceof yerror_1.YError)\n                usage.fail(err.message, err);\n            else\n                throw err;\n        }\n        return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n    };\n    // to simplify the parsing of positionals in commands,\n    // we temporarily populate '--' rather than _, with arguments\n    // after the '--' directive. After the parse, we copy these back.\n    self._copyDoubleDash = function (argv) {\n        if (is_promise_1.isPromise(argv) || !argv._ || !argv['--'])\n            return argv;\n        argv._.push.apply(argv._, argv['--']);\n        // TODO(bcoe): refactor command parsing such that this delete is not\n        // necessary: https://github.com/yargs/yargs/issues/1482\n        try {\n            delete argv['--'];\n        }\n        catch (_err) { }\n        return argv;\n    };\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n        if (parseErrors)\n            throw new yerror_1.YError(parseErrors.message);\n        validation.nonOptionCount(argv);\n        validation.requiredArguments(argv);\n        let failedStrictCommands = false;\n        if (strictCommands) {\n            failedStrictCommands = validation.unknownCommands(argv);\n        }\n        if (strict && !failedStrictCommands) {\n            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n        }\n        validation.customChecks(argv, aliases);\n        validation.limitedChoices(argv);\n        validation.implications(argv);\n        validation.conflicting(argv);\n    };\n    function guessLocale() {\n        if (!detectLocale)\n            return;\n        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || 'en_US';\n        self.locale(locale.replace(/[.:].*/, ''));\n    }\n    // an app should almost always have --version and --help,\n    // if you *really* want to disable this use .help(false)/.version(false).\n    self.help();\n    self.version();\n    return self;\n}\nexports.Yargs = Yargs;\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nfunction rebase(base, dir) {\n    return path.relative(base, dir);\n}\nexports.rebase = rebase;\nfunction isYargsInstance(y) {\n    return !!y && (typeof y._parseArgs === 'function');\n}\nexports.isYargsInstance = isYargsInstance;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.YError = void 0;\nclass YError extends Error {\n    constructor(msg) {\n        super(msg || 'yargs error');\n        this.name = 'YError';\n        Error.captureStackTrace(this, YError);\n    }\n}\nexports.YError = YError;\n","'use strict'\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = require('./yargs')\nconst processArgv = require('./build/lib/process-argv')\n\nArgv(processArgv.getProcessArgvWithoutBin())\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, require)\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach((key) => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst)\n    } else {\n      Argv.__defineGetter__('$0', () => {\n        return inst.$0\n      })\n      Argv.__defineGetter__('parsed', () => {\n        return inst.parsed\n      })\n    }\n  })\n}\n","'use strict'\n\n// an async function fails early in Node.js versions prior to 8.\nasync function requiresNode8OrGreater () {}\nrequiresNode8OrGreater()\n\nconst { Yargs, rebase } = require('./build/lib/yargs')\nconst Parser = require('yargs-parser')\n\nexports = module.exports = Yargs\nexports.rebase = rebase\n\n// allow consumers to directly use the version of yargs-parser used by yargs\nexports.Parser = Parser\n","import CaseFormat from '@/dsl/generator/common/case-format/CaseFormat';\n\nconst CAMEL_CASE_WORD_BOUNDARIES_REGEX = /((?<=[^A-Z])(?=[A-Z])|(?=[A-Z][a-z]))/;\n\nexport default abstract class AbstractCamelCaseFormat implements CaseFormat {\n\n\tabstract joinWords(words: string[]): string;\n\n\tpublic splitWords(text: string): string[] {\n\t\treturn text.split(CAMEL_CASE_WORD_BOUNDARIES_REGEX)\n\t\t\t\t.filter(chunk => chunk.length > 0)\n\t}\n\n}\n","import CaseFormat from '@/dsl/generator/common/case-format/CaseFormat';\n\nexport default abstract class AbstractUnderscoreCaseFormat implements CaseFormat {\n\n\tabstract joinWords(words: string[]): string;\n\n\tpublic splitWords(text: string): string[] {\n\t\treturn text.split('_');\n\t}\n\n}\n","import AbstractUnderscoreCaseFormat from '@/dsl/generator/common/case-format/AbstractUnderscoreCaseFormat';\nimport {capitalize} from '@/dsl/util/string-utils';\n\nexport default class CapitalizedUnderscoreCaseFormat extends AbstractUnderscoreCaseFormat {\n\n\tpublic joinWords(words: string[]): string {\n\t\treturn words\n\t\t\t\t.map(word => word.toLowerCase())\n\t\t\t\t.map(capitalize)\n\t\t\t\t.join('_');\n\t}\n\n}\n","import AbstractCamelCaseFormat from '@/dsl/generator/common/case-format/AbstractCamelCaseFormat';\nimport {capitalize} from '@/dsl/util/string-utils';\n\nexport default class LowerCamelCaseFormat extends AbstractCamelCaseFormat {\n\n\tpublic joinWords(words: string[]): string {\n\n\t\tif (words.length === 0) {\n\t\t\treturn '';\n\t\t}\n\n\t\tconst [firstWord, ...otherWords] = words;\n\n\t\tconst lowerCaseFirstWord = firstWord.toLowerCase();\n\n\t\tconst capitalizedOtherWords = otherWords\n\t\t\t\t.map(word => word.toLowerCase())\n\t\t\t\t.map(capitalize);\n\n\t\treturn lowerCaseFirstWord + capitalizedOtherWords.join('');\n\n\t}\n\n}\n","import AbstractUnderscoreCaseFormat from '@/dsl/generator/common/case-format/AbstractUnderscoreCaseFormat';\n\nexport default class LowerUnderscoreCaseFormat extends AbstractUnderscoreCaseFormat {\n\n\tpublic joinWords(words: string[]): string {\n\t\treturn words\n\t\t\t\t.map(word => word.toLowerCase())\n\t\t\t\t.join('_');\n\t}\n\n}\n","import LowerCamelCaseFormat from '@/dsl/generator/common/case-format/LowerCamelCaseFormat';\nimport UpperCamelCaseFormat from '@/dsl/generator/common/case-format/UpperCamelCaseFormat';\nimport LowerUnderscoreCaseFormat from '@/dsl/generator/common/case-format/LowerUnderscoreCaseFormat';\nimport CapitalizedUnderscoreCaseFormat from '@/dsl/generator/common/case-format/CapitalizedUnderscoreCaseFormat';\nimport UpperUnderscoreCaseFormat from '@/dsl/generator/common/case-format/UpperUnderscoreCaseFormat';\n\nconst StandardCaseFormats = {\n\tLOWER_CAMEL: new LowerCamelCaseFormat(),\n\tUPPER_CAMEL: new UpperCamelCaseFormat(),\n\tLOWER_UNDERSCORE: new LowerUnderscoreCaseFormat(),\n\tCAPITALIZED_UNDERSCORE: new CapitalizedUnderscoreCaseFormat(),\n\tUPPER_UNDERSCORE: new UpperUnderscoreCaseFormat(),\n};\n\nexport default StandardCaseFormats;\n","import AbstractCamelCaseFormat from '@/dsl/generator/common/case-format/AbstractCamelCaseFormat';\nimport {capitalize} from '@/dsl/util/string-utils';\n\nexport default class UpperCamelCaseFormat extends AbstractCamelCaseFormat {\n\n\tpublic joinWords(words: string[]): string {\n\t\treturn words\n\t\t\t\t.map(word => word.toLowerCase())\n\t\t\t\t.map(capitalize)\n\t\t\t\t.join('');\n\t}\n\n}\n","import AbstractUnderscoreCaseFormat from '@/dsl/generator/common/case-format/AbstractUnderscoreCaseFormat';\n\nexport default class UpperUnderscoreCaseFormat extends AbstractUnderscoreCaseFormat {\n\n\tpublic joinWords(words: string[]): string {\n\t\treturn words\n\t\t\t\t.map(word => word.toUpperCase())\n\t\t\t\t.join('_');\n\t}\n\n}\n","import {uncapitalize} from '@/dsl/util/string-utils';\n\ntype IdNamingStrategy = (entityName: string) => string;\nexport default IdNamingStrategy;\n\nconst defaultIdNamingStrategy: IdNamingStrategy = () => 'id';\nconst entityNamePrefixIdNamingStrategy: IdNamingStrategy = entityName => `${uncapitalize(entityName)}Id`;\n\nexport const StandardIdNamingStrategies = {\n\tDEFAULT: defaultIdNamingStrategy,\n\tENTITY_NAME_PREFIX: entityNamePrefixIdNamingStrategy\n};\n","import {EntityRelationshipModel} from '../../../parser/er-model-parser';\nimport {\n\tCardinality,\n\tEntityDescriptor,\n\tEntityPropertyDescriptor,\n\tEntityPropertyType,\n\tRelationshipDescriptor,\n\tRelationshipMember\n} from '../../../parser/statement/statement-types-parse-functions';\nimport {capitalize} from '../../../util/string-utils';\nimport {DatabaseModel, TableColumnDescriptor, TableDescriptor, TableReferenceDescriptor} from './database-model-types';\n\nexport interface DatabaseModelGenerator {\n\tgenerateDatabaseModel(model: EntityRelationshipModel): DatabaseModel;\n}\n\nconst databaseModelGenerator: DatabaseModelGenerator = {\n\n\tgenerateDatabaseModel(model: EntityRelationshipModel): DatabaseModel {\n\n\t\tconst tables: TableDescriptor[] = [];\n\n\t\tmodel.entities\n\t\t\t\t.map(entity => generateEntityTable(entity, model))\n\t\t\t\t.forEach(sentence => tables.push(sentence));\n\n\t\tmodel.relationships\n\t\t\t\t.filter(isManyToManyRelationship)\n\t\t\t\t.map(relationship => generateRelationshipTable(relationship))\n\t\t\t\t.forEach(sentence => tables.push(sentence));\n\n\t\treturn {\n\t\t\ttables\n\t\t};\n\n\t}\n\n};\n\nexport default databaseModelGenerator;\n\nfunction generateEntityTable(entity: EntityDescriptor, model: EntityRelationshipModel): TableDescriptor {\n\n\tconst name = capitalize(entity.name);\n\tconst id = getTableIdColumnName(name);\n\n\tconst columns: TableColumnDescriptor[] = [];\n\tconst references: TableReferenceDescriptor[] = [];\n\n\tfor (const property of entity.properties) {\n\t\tcolumns.push(mapPropertyToColumn(property));\n\t}\n\n\tfor (const relationship of model.relationships) {\n\t\tif (relationship.rightMember.cardinality === Cardinality.ONE) {\n\t\t\tif (relationship.leftMember.entity === entity.name) {\n\t\t\t\treferences.push(createTableReference(relationship.rightMember));\n\t\t\t}\n\t\t} else if (relationship.leftMember.cardinality === Cardinality.ONE) {\n\t\t\tif (relationship.rightMember.entity === entity.name) {\n\t\t\t\treferences.push(createTableReference(relationship.leftMember));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tname,\n\t\tid,\n\t\tcolumns,\n\t\treferences\n\t};\n\n}\n\nfunction generateRelationshipTable(relationship: RelationshipDescriptor): TableDescriptor {\n\n\tconst name = capitalize(relationship.relationShipName);\n\tconst id = getTableIdColumnName(name);\n\n\treturn {\n\t\tname,\n\t\tid,\n\t\tcolumns: [],\n\t\treferences: [\n\t\t\tcreateTableReference(relationship.leftMember),\n\t\t\tcreateTableReference(relationship.rightMember)\n\t\t]\n\t};\n\n}\n\nfunction createTableReference(toMember: RelationshipMember): TableReferenceDescriptor {\n\treturn {\n\t\talias: toMember.entityAlias,\n\t\tcolumnName: `${toMember.entityAlias}Id`,\n\t\ttargetTableName: toMember.entity,\n\t\tnotNull: !toMember.optional\n\t};\n}\n\nfunction mapRelationshipMemberToColumn(toMember: RelationshipMember): TableColumnDescriptor {\n\treturn {\n\t\tname: toMember.entityAlias,\n\t\tnotNull: !toMember.optional,\n\t\ttype: EntityPropertyType.LONG\n\t};\n}\n\nfunction getTableIdColumnName(tableName: string) {\n\t// TODO definir diferentes estrategias\n\t// return uncapitalize(tableName) + 'Id';\n\treturn 'id';\n}\n\nfunction mapPropertyToColumn(property: EntityPropertyDescriptor): TableColumnDescriptor {\n\n\tconst {\n\t\tname,\n\t\toptional,\n\t\ttype,\n\t\tlength\n\t} = property;\n\n\treturn {\n\t\tname,\n\t\tnotNull: !optional,\n\t\ttype,\n\t\tlength\n\t};\n\n}\n\nfunction isManyToManyRelationship(relationship: RelationshipDescriptor): boolean {\n\treturn [\n\t\trelationship.leftMember,\n\t\trelationship.rightMember\n\t].every(member => member.cardinality === Cardinality.MANY);\n}\n","import EntityRelationshipModelToCodeConverter from '@/dsl/generator/entity-relationship-to-code-converter';\nimport {EntityRelationshipModel} from '@/dsl/parser/er-model-parser';\nimport {EntityPropertyType} from '@/dsl/parser/statement/statement-types-parse-functions';\nimport databaseModelGenerator from '@/dsl/generator/database/database-model/database-model-generator';\nimport {\n\tDatabaseModel,\n\tTableColumnDescriptor,\n\tTableDescriptor,\n\tTableReferenceDescriptor\n} from '@/dsl/generator/database/database-model/database-model-types';\nimport MySqlCodeGeneratorConfig, {mergeWithDefaultConfig} from '@/dsl/generator/database/sql/mysql/mysql-code-generator-config';\n\nconst INDENT: string = '    ';\n\nexport default class MySqlCodeGenerator implements EntityRelationshipModelToCodeConverter {\n\n\tprivate readonly config: MySqlCodeGeneratorConfig;\n\n\tconstructor(config?: Partial<MySqlCodeGeneratorConfig>) {\n\t\tthis.config = mergeWithDefaultConfig(config);\n\t}\n\n\tpublic generateCode(entityRelationshipModel: EntityRelationshipModel): string {\n\n\t\tconst databaseModel = databaseModelGenerator.generateDatabaseModel(entityRelationshipModel);\n\n\t\treturn databaseModel.tables\n\t\t\t\t.map(table => this.generateTable(table, databaseModel))\n\t\t\t\t.join('\\n\\n');\n\n\t}\n\n\tprivate generateTable(table: TableDescriptor, model: DatabaseModel): string {\n\n\t\tconst tableId = this.getTableId(table.name);\n\n\t\tconst columnLines: string[] = [\n\t\t\tthis.createIdColumn(tableId)\n\t\t];\n\n\t\tconst constraintLines: string[] = [\n\t\t\tthis.createPrimaryKeyConstraint(table, tableId)\n\t\t];\n\n\t\tfor (const column of table.columns) {\n\t\t\tcolumnLines.push(this.createColumn(column));\n\t\t}\n\n\t\tfor (const reference of table.references) {\n\n\t\t\tconst {\n\t\t\t\tcolumnLine,\n\t\t\t\tconstraintLine\n\t\t\t} = this.createForeignColumn(table.name, reference, model);\n\n\t\t\tcolumnLines.push(columnLine);\n\t\t\tconstraintLines.push(constraintLine);\n\n\t\t}\n\n\t\tconst lines = [\n\t\t\t...columnLines,\n\t\t\t...constraintLines\n\t\t];\n\n\t\treturn [\n\t\t\t`CREATE TABLE ${table.name} (`,\n\t\t\tindentLines(lines).join(',\\n'),\n\t\t\t');'\n\t\t].join('\\n');\n\n\t}\n\n\tprivate createPrimaryKeyConstraint(table: TableDescriptor, tableId: string) {\n\t\treturn `CONSTRAINT ${table.name}_pk PRIMARY KEY (${tableId})`;\n\t}\n\n\tprivate createIdColumn(tableId: string) {\n\n\t\tconst columnCode = this.createColumn({\n\t\t\tname: tableId,\n\t\t\ttype: EntityPropertyType.LONG,\n\t\t\tnotNull: true\n\t\t});\n\n\t\treturn columnCode + ' AUTO_INCREMENT';\n\n\t}\n\n\tprivate createColumn(column: TableColumnDescriptor) {\n\n\t\tconst {\n\t\t\tname,\n\t\t\tnotNull,\n\t\t\ttype,\n\t\t\tlength\n\t\t} = column;\n\n\t\tconst lineParts: string[] = [];\n\t\tlineParts.push(name);\n\n\t\tconst mysqlType = this.mapPropertyTypeToSqlType(type);\n\n\t\tif (length) {\n\t\t\tlineParts.push(`${mysqlType}(${length})`);\n\t\t} else {\n\t\t\tlineParts.push(mysqlType);\n\t\t}\n\n\t\tif (notNull) {\n\t\t\tlineParts.push('NOT NULL');\n\t\t}\n\n\t\treturn lineParts.join(' ');\n\n\t}\n\n\tprivate createForeignColumn(sourceTableName: string, reference: TableReferenceDescriptor, model: DatabaseModel) {\n\n\t\tconst column: TableColumnDescriptor = {\n\t\t\tname: reference.columnName,\n\t\t\ttype: EntityPropertyType.LONG,\n\t\t\tnotNull: reference.notNull\n\t\t};\n\n\t\treturn {\n\t\t\tcolumnLine: this.createColumn(column),\n\t\t\tconstraintLine: this.createForeignKey(sourceTableName, reference)\n\t\t};\n\n\t}\n\n\tprivate createForeignKey(sourceTableName: string, reference: TableReferenceDescriptor) {\n\t\treturn `CONSTRAINT ${sourceTableName}_${reference.alias}_fk FOREIGN KEY (${reference.columnName})`\n\t\t\t\t+ ` REFERENCES ${reference.targetTableName} (${this.getTableId(reference.targetTableName)})`;\n\t}\n\n\tprivate getTableId(entityName: string) {\n\t\tconst {idNamingStrategy} = this.config;\n\t\treturn idNamingStrategy(entityName);\n\t}\n\n\tprivate mapPropertyTypeToSqlType(type: EntityPropertyType): string {\n\n\t\tconst {typesMap} = this.config;\n\n\t\tif (!typesMap.hasOwnProperty(type)) {\n\t\t\tthrow new Error('Unsupported type: ' + type);\n\t\t}\n\n\t\treturn typesMap[type];\n\n\t}\n\n}\n\nfunction indentLines(lines: string[]) {\n\treturn lines.map(e => INDENT + e);\n}\n","import IdNamingStrategy, {StandardIdNamingStrategies} from '@/dsl/generator/common/id-naming-strategy';\nimport {EntityPropertyType} from '@/dsl/parser/statement/statement-types-parse-functions';\n\nexport default interface MySqlCodeGeneratorConfig {\n\tidNamingStrategy: IdNamingStrategy;\n\ttypesMap: Record<string, string>;\n}\n\nexport const defaultMySqlCodeGeneratorConfig: MySqlCodeGeneratorConfig = {\n\tidNamingStrategy: StandardIdNamingStrategies.DEFAULT,\n\ttypesMap: {\n\t\t[EntityPropertyType.TEXT]: 'VARCHAR',\n\t\t[EntityPropertyType.LONG]: 'BIGINT',\n\t\t[EntityPropertyType.INT]: 'INT',\n\t\t[EntityPropertyType.DECIMAL]: 'DECIMAL',\n\t\t[EntityPropertyType.BOOLEAN]: 'BOOLEAN',\n\t\t[EntityPropertyType.DATE]: 'DATE',\n\t\t[EntityPropertyType.TIME]: 'TIME',\n\t\t[EntityPropertyType.DATETIME]: 'TIMESTAMP'\n\t}\n};\n\nexport function mergeWithDefaultConfig(config?: Partial<MySqlCodeGeneratorConfig>): MySqlCodeGeneratorConfig {\n\treturn {\n\t\t...defaultMySqlCodeGeneratorConfig,\n\t\t...config,\n\t\ttypesMap: {\n\t\t\t...defaultMySqlCodeGeneratorConfig.typesMap,\n\t\t\t...config?.typesMap\n\t\t}\n\t};\n}\n","import pluralize from 'pluralize';\nimport {EntityRelationshipModel} from '../../../parser/er-model-parser';\nimport {\n\tCardinality,\n\tDirection,\n\tEntityDescriptor,\n\tEntityPropertyDescriptor,\n\tEntityPropertyType,\n\tRelationshipMember\n} from '../../../parser/statement/statement-types-parse-functions';\nimport {capitalize} from '../../../util/string-utils';\nimport {ClassDescriptor, ClassModel, FieldDescriptor} from './class-model-types';\n\nexport interface ClassModelGenerator {\n\tgenerateClassModel(model: EntityRelationshipModel): ClassModel;\n}\n\nconst classModelGenerator: ClassModelGenerator = {\n\n\tgenerateClassModel(model: EntityRelationshipModel): ClassModel {\n\n\t\tconst classes: ClassDescriptor[] = [];\n\n\t\tmodel.entities\n\t\t\t\t.map(entity => generateEntityTable(entity, model))\n\t\t\t\t.forEach(sentence => classes.push(sentence));\n\n\t\treturn {\n\t\t\tclasses\n\t\t};\n\n\t}\n\n};\n\nexport default classModelGenerator;\n\nfunction generateEntityTable(entity: EntityDescriptor, model: EntityRelationshipModel): ClassDescriptor {\n\n\tconst name = capitalize(entity.name);\n\n\tconst fields: FieldDescriptor[] = [\n\t\tcreateIdField()\n\t];\n\n\tfor (const property of entity.properties) {\n\t\tfields.push(mapPropertyToField(property));\n\t}\n\n\tfor (const relationship of model.relationships) {\n\n\t\tconst {\n\t\t\tleftMember,\n\t\t\trightMember,\n\t\t\tdirection\n\t\t} = relationship;\n\n\t\tif (leftMember.entity === entity.name && [Direction.RIGHT, Direction.BOTH].includes(direction)) {\n\t\t\tfields.push(mapRelationshipMemberToField(rightMember));\n\t\t}\n\n\t\tif (rightMember.entity === entity.name && [Direction.LEFT, Direction.BOTH].includes(direction)) {\n\t\t\tfields.push(mapRelationshipMemberToField(leftMember));\n\t\t}\n\n\t}\n\n\treturn {\n\t\tname,\n\t\tfields\n\t};\n\n}\n\nfunction createIdField(): FieldDescriptor {\n\treturn {\n\t\tname: 'id',\n\t\tprimitiveType: EntityPropertyType.LONG,\n\t\tnullable: false,\n\t\tlist: false\n\t};\n}\n\nfunction mapRelationshipMemberToField(toMember: RelationshipMember): FieldDescriptor {\n\n\tconst list = toMember.cardinality === Cardinality.MANY;\n\tconst name = list ? pluralize(toMember.entityAlias) : toMember.entityAlias;\n\n\treturn {\n\t\tname,\n\t\tnullable: toMember.optional,\n\t\tentityType: toMember.entity,\n\t\tlist\n\t};\n\n}\n\nfunction mapPropertyToField(property: EntityPropertyDescriptor): FieldDescriptor {\n\n\tconst {\n\t\tname,\n\t\toptional,\n\t\ttype\n\t} = property;\n\n\treturn {\n\t\tname,\n\t\tnullable: optional,\n\t\tprimitiveType: type,\n\t\tlist: false\n\t};\n\n}\n","import EntityRelationshipModelToCodeConverter from 'src/dsl/generator/entity-relationship-to-code-converter';\nimport {EntityRelationshipModel} from '../../../parser/er-model-parser';\nimport {EntityPropertyType} from '../../../parser/statement/statement-types-parse-functions';\nimport {capitalize} from '../../../util/string-utils';\nimport classModelGenerator from '../class-model/class-model-generator';\nimport {ClassDescriptor, FieldDescriptor} from '../class-model/class-model-types';\n\nconst INDENT: string = '    ';\nconst BLANK_LINE: string = '';\n\nexport default class JavaCodeGenerator implements EntityRelationshipModelToCodeConverter {\n\n\tpublic generateCode(entityRelationshipModel: EntityRelationshipModel): string {\n\n\t\tconst classModel = classModelGenerator.generateClassModel(entityRelationshipModel);\n\n\t\treturn classModel.classes\n\t\t\t\t.map(classDescriptor => this.generateClass(classDescriptor))\n\t\t\t\t.join('\\n\\n');\n\n\t}\n\n\tprivate generateClass(classDescriptor: ClassDescriptor): string {\n\n\t\tconst className = capitalize(classDescriptor.name);\n\n\t\tconst fieldsLines: string[] = [];\n\t\tconst methodsLines: string[] = [];\n\n\t\tfor (const field of classDescriptor.fields) {\n\n\t\t\tconst {\n\t\t\t\tfieldLines,\n\t\t\t\tgetterLines,\n\t\t\t\tsetterLines\n\t\t\t} = this.createField(field);\n\n\t\t\tfieldsLines.push(...fieldLines);\n\t\t\tmethodsLines.push(...getterLines, BLANK_LINE, ...setterLines, BLANK_LINE);\n\n\t\t}\n\n\t\tconst classContentLines: string[] = [\n\t\t\tBLANK_LINE,\n\t\t\t...fieldsLines,\n\t\t\tBLANK_LINE,\n\t\t\t...methodsLines\n\t\t];\n\n\t\treturn [\n\t\t\t`public class ${className} {`,\n\t\t\tindentLines(classContentLines).join('\\n'),\n\t\t\t'}'\n\t\t].join('\\n');\n\n\t}\n\n\tprivate createField(field: FieldDescriptor) {\n\n\t\tconst fieldName = field.name;\n\t\tconst capitalizedFieldName = capitalize(fieldName);\n\n\t\tconst fieldLines = [];\n\n\t\t// TODO use length for validation annotations?\n\n\t\tif (field.nullable) {\n\t\t\tfieldLines.push('@Nullable');\n\t\t}\n\n\t\tconst javaType = mapFieldTypeToJavaType(field);\n\n\t\tfieldLines.push(`private ${javaType} ${fieldName};`);\n\n\t\tconst getterLines: string[] = [\n\t\t\t`public ${javaType} get${capitalizedFieldName}() {`,\n\t\t\t`${INDENT}return ${fieldName};`,\n\t\t\t'}',\n\t\t];\n\n\t\tconst setterLines: string[] = [\n\t\t\t`public ${javaType} set${capitalizedFieldName}(${javaType} ${fieldName}) {`,\n\t\t\t`${INDENT}this.${fieldName} = ${fieldName};`,\n\t\t\t'}',\n\t\t];\n\n\t\treturn {\n\t\t\tfieldLines,\n\t\t\tgetterLines,\n\t\t\tsetterLines\n\t\t};\n\n\t}\n\n}\n\nfunction indentLines(lines: string[]) {\n\treturn lines.map(e => {\n\t\tif (e.trim().length === 0) {\n\t\t\treturn e;\n\t\t}\n\t\treturn INDENT + e;\n\t});\n}\n\nfunction mapFieldTypeToJavaType(field: FieldDescriptor): string {\n\tif (field.list) {\n\t\treturn mapListTypeToJavaType(field);\n\t} else {\n\t\treturn mapSingleTypeToJavaType(field);\n\t}\n}\n\nfunction mapListTypeToJavaType(field: FieldDescriptor): string {\n\treturn `List<${mapSingleTypeToJavaType(field)}>`;\n}\n\nfunction mapSingleTypeToJavaType(field: FieldDescriptor): string {\n\n\tconst {\n\t\tentityType,\n\t\tprimitiveType\n\t} = field;\n\n\tif (entityType) {\n\n\t\tif (primitiveType) {\n\t\t\tthrow new Error('Invalid field descriptor: provided both primitive and entity types');\n\t\t}\n\n\t\treturn entityType;\n\n\t}\n\n\tif (!primitiveType) {\n\t\tthrow new Error('Invalid field descriptor: missing type');\n\t}\n\n\tconst typesMap: Record<string, string> = {\n\t\t[EntityPropertyType.TEXT]: 'String',\n\t\t[EntityPropertyType.LONG]: 'Long',\n\t\t[EntityPropertyType.INT]: 'Integer',\n\t\t[EntityPropertyType.DECIMAL]: 'BigDecimal',\n\t\t[EntityPropertyType.BOOLEAN]: 'Boolean',\n\t\t[EntityPropertyType.DATE]: 'LocalDate',\n\t\t[EntityPropertyType.TIME]: 'LocalTime',\n\t\t[EntityPropertyType.DATETIME]: 'LocalDateTime'\n\t};\n\n\tif (!typesMap.hasOwnProperty(primitiveType)) {\n\t\tthrow new Error('Unsupported type: ' + primitiveType);\n\t}\n\n\treturn typesMap[primitiveType];\n\n}\n","import {\n\tBaseDescriptor,\n\tEntityDescriptor,\n\tparseEntityNameStatement,\n\tparseEntityPropertyStatement,\n\tparseMetadataStatement,\n\tparseRelationshipStatement,\n\tRelationshipDescriptor\n} from './statement/statement-types-parse-functions';\nimport {guessStatementType, StatementType} from './statement/statement-type-guesser';\n\nexport interface EntityRelationshipModel {\n\tentities: EntityDescriptor[];\n\trelationships: RelationshipDescriptor[];\n}\n\nexport function parseEntityRelationshipModel(code: string): EntityRelationshipModel {\n\n\tconst lines = code.split('\\n');\n\n\tconst entities: EntityDescriptor[] = [];\n\tconst relationships: RelationshipDescriptor[] = [];\n\n\tlet lastDescriptorRead: BaseDescriptor | null = null;\n\tlet parsingEntity = false;\n\n\tlines.forEach(line => {\n\n\t\tconst statementType = guessStatementType(line);\n\n\t\tswitch (statementType) {\n\t\t\tcase StatementType.ENTITY_NAME:\n\t\t\t\tconst entityDescriptor = {\n\t\t\t\t\tname: parseEntityNameStatement(line),\n\t\t\t\t\tproperties: [],\n\t\t\t\t\tmetadata: []\n\t\t\t\t};\n\t\t\t\tentities.push(entityDescriptor);\n\t\t\t\tlastDescriptorRead = entityDescriptor;\n\t\t\t\tparsingEntity = true;\n\t\t\t\tbreak;\n\t\t\tcase StatementType.ENTITY_PROPERTY:\n\t\t\t\tif (!parsingEntity) {\n\t\t\t\t\tthrow new Error('Unexpected entity property statement');\n\t\t\t\t}\n\t\t\t\tconst lastEntity = entities[entities.length - 1];\n\t\t\t\tconst entityPropertyDescriptor = parseEntityPropertyStatement(line);\n\t\t\t\tlastEntity.properties.push(entityPropertyDescriptor);\n\t\t\t\tlastDescriptorRead = entityPropertyDescriptor;\n\t\t\t\tbreak;\n\t\t\tcase StatementType.RELATIONSHIP:\n\t\t\t\tconst relationshipDescriptor = parseRelationshipStatement(line);\n\t\t\t\trelationships.push(relationshipDescriptor);\n\t\t\t\tlastDescriptorRead = relationshipDescriptor;\n\t\t\t\tparsingEntity = false;\n\t\t\t\tbreak;\n\t\t\tcase StatementType.METADATA:\n\t\t\t\tif (lastDescriptorRead == null) {\n\t\t\t\t\tthrow new Error('Unexpected metadata statement');\n\t\t\t\t}\n\t\t\t\tconst metadata = parseMetadataStatement(line);\n\t\t\t\tlastDescriptorRead.metadata.push(metadata);\n\t\t\t\tbreak;\n\t\t\tcase StatementType.BLANK_LINE:\n\t\t\tcase StatementType.COMMENT:\n\t\t\t\t// Ignore\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown statement type: ' + statementType);\n\t\t}\n\n\t});\n\n\treturn validateModel({\n\t\tentities,\n\t\trelationships\n\t});\n\n}\n\nfunction validateModel(model: EntityRelationshipModel) {\n\n\tconst entityNames = model.entities.map(e => e.name);\n\n\tmodel.relationships.forEach(r => {\n\t\tif (!entityNames.includes(r.leftMember.entity)) {\n\t\t\tthrow new Error(`Uknown entity in relationship's left side: ${r.leftMember.entity}`);\n\t\t}\n\t\tif (!entityNames.includes(r.rightMember.entity)) {\n\t\t\tthrow new Error(`Uknown entity in relationship's right side: ${r.rightMember.entity}`);\n\t\t}\n\t});\n\n\treturn model;\n\n}\n","import {\n\tENTITY_NAME_LINE_REGEX,\n\tENTITY_PROPERTY_LINE_REGEX,\n\tMETADATA_LINE_REGEX,\n\tRELATIONSHIP_LINE_REGEX\n} from './statement-types-regexes';\n\nexport enum StatementType {\n\tENTITY_NAME = 'entityName',\n\tENTITY_PROPERTY = 'entityProperty',\n\tRELATIONSHIP = 'relationship',\n\tMETADATA = 'metadata',\n\tCOMMENT = 'comment',\n\tBLANK_LINE = 'blankLine',\n\tUNKNOWN = 'unknown'\n}\n\nexport function guessStatementType(line: string): StatementType {\n\tif (ENTITY_NAME_LINE_REGEX.test(line)) {\n\t\treturn StatementType.ENTITY_NAME;\n\t} else if (ENTITY_PROPERTY_LINE_REGEX.test(line)) {\n\t\treturn StatementType.ENTITY_PROPERTY;\n\t} else if (RELATIONSHIP_LINE_REGEX.test(line)) {\n\t\treturn StatementType.RELATIONSHIP;\n\t} else if (METADATA_LINE_REGEX.test(line)) {\n\t\treturn StatementType.METADATA;\n\t} else if (isBlankLine(line)) {\n\t\treturn StatementType.BLANK_LINE;\n\t} else if (isCommentLine(line)) {\n\t\treturn StatementType.COMMENT;\n\t} else {\n\t\treturn StatementType.UNKNOWN;\n\t}\n}\n\nfunction isBlankLine(line: string) {\n\treturn line.trim().length === 0;\n}\n\nfunction isCommentLine(line: string) {\n\treturn line.trim()[0] === '#';\n}\n","import {capitalize, uncapitalize} from '../../util/string-utils';\nimport {\n\tENTITY_NAME_LINE_REGEX,\n\tENTITY_PROPERTY_LINE_REGEX,\n\tMETADATA_LINE_REGEX,\n\tRELATIONSHIP_LINE_REGEX\n} from './statement-types-regexes';\n\nexport enum Cardinality {\n\tMANY = 'many',\n\tONE = 'one'\n}\n\nexport enum Direction {\n\tLEFT = 'left',\n\tRIGHT = 'right',\n\tBOTH = 'both'\n}\n\nexport interface BaseDescriptor {\n\tmetadata: Metadata[];\n}\n\nexport interface RelationshipDescriptor extends BaseDescriptor {\n\tleftMember: RelationshipMember;\n\trightMember: RelationshipMember;\n\tdirection: Direction;\n\trelationShipName: string;\n}\n\nexport interface RelationshipMember {\n\tentity: string;\n\tentityAlias: string;\n\tcardinality: Cardinality;\n\toptional: boolean;\n}\n\nexport interface EntityDescriptor extends BaseDescriptor {\n\tname: string;\n\tproperties: EntityPropertyDescriptor[];\n}\n\nexport interface EntityPropertyDescriptor extends BaseDescriptor {\n\tname: string;\n\toptional: boolean;\n\ttype: EntityPropertyType;\n\tlength?: number;\n}\n\nexport enum EntityPropertyType {\n\tTEXT = 'text',\n\tLONG = 'long',\n\tINT = 'int',\n\tDECIMAL = 'decimal',\n\tBOOLEAN = 'bool',\n\tDATE = 'date',\n\tTIME = 'time',\n\tDATETIME = 'datetime'\n}\n\nexport interface Metadata {\n\tkey: string;\n\tvalue: string;\n}\n\nexport function parseEntityNameStatement(line: string): string {\n\n\tconst result = ENTITY_NAME_LINE_REGEX.exec(line);\n\n\tif (result == null) {\n\t\tthrow new Error('Syntax error');\n\t}\n\n\tconst [entityName] = result;\n\n\treturn entityName;\n\n}\n\nexport function parseEntityPropertyStatement(line: string): EntityPropertyDescriptor {\n\n\tconst result = ENTITY_PROPERTY_LINE_REGEX.exec(line);\n\n\tif (result == null) {\n\t\tthrow new Error('Syntax error');\n\t}\n\n\tconst [\n\t\tfullMatch,\n\t\tname,\n\t\toptionalModifier,\n\t\ttype,\n\t\tlength\n\t] = result;\n\n\tconst mappedType = type.toLowerCase() as EntityPropertyType;\n\n\tif (!Object.values(EntityPropertyType).includes(mappedType)) {\n\t\tthrow new Error('Unknown type: ' + type);\n\t}\n\n\treturn {\n\t\tname,\n\t\toptional: optionalModifier === '?',\n\t\ttype: mappedType,\n\t\tlength: length ? parseInt(length, 10) : undefined,\n\t\tmetadata: []\n\t};\n\n}\n\nexport function parseRelationshipStatement(line: string): RelationshipDescriptor {\n\n\tconst result = RELATIONSHIP_LINE_REGEX.exec(line);\n\n\tif (result == null) {\n\t\tthrow new Error('Syntax error');\n\t}\n\n\tconst [\n\t\tfullMatch,\n\t\tleftEntity,\n\t\tleftEntityAlias = uncapitalize(leftEntity),\n\t\tleftCardinality,\n\t\tdirection,\n\t\trightCardinality,\n\t\trightEntity,\n\t\trightEntityAlias = uncapitalize(rightEntity),\n\t\trelationShipName = `${leftEntity}${capitalize(rightEntity)}`\n\t] = result;\n\n\treturn {\n\t\tleftMember: {\n\t\t\tentity: leftEntity,\n\t\t\tentityAlias: leftEntityAlias,\n\t\t\tcardinality: leftCardinality === '*' ? Cardinality.MANY : Cardinality.ONE,\n\t\t\toptional: leftCardinality === '?'\n\t\t},\n\t\trightMember: {\n\t\t\tentity: rightEntity,\n\t\t\tentityAlias: rightEntityAlias,\n\t\t\tcardinality: rightCardinality === '*' ? Cardinality.MANY : Cardinality.ONE,\n\t\t\toptional: rightCardinality === '?'\n\t\t},\n\t\tdirection: direction === '->' ? Direction.RIGHT : (direction === '<-' ? Direction.LEFT : Direction.BOTH),\n\t\trelationShipName,\n\t\tmetadata: []\n\t};\n\n}\n\nexport function parseMetadataStatement(line: string): Metadata {\n\n\tconst result = METADATA_LINE_REGEX.exec(line);\n\n\tif (result == null) {\n\t\tthrow new Error('Syntax error');\n\t}\n\n\tconst [\n\t\tfullMatch,\n\t\tkey,\n\t\tvalue\n\t] = result;\n\n\treturn {\n\t\tkey,\n\t\tvalue\n\t};\n\n}\n","import {joinRegExps} from '../../util/regex-utils';\n\nconst IDENTIFIER_REGEX = /[a-zA-Z_][a-zA-Z_0-9]*/;\n\n// Entity name\n\nexport const ENTITY_NAME_LINE_REGEX = new RegExp(`^${IDENTIFIER_REGEX.source}$`);\n\n// Entity property\n\nconst PROPERTY_NAME_REGEX = new RegExp(`(${IDENTIFIER_REGEX.source})`);\nconst OPTIONAL_PROPERTY_MODIFIER_REGEX = new RegExp(`(\\\\?)?`);\n\nconst PROPERTY_TYPE_NAME_REGEX = new RegExp(`(${IDENTIFIER_REGEX.source})`);\nconst PROPERTY_TYPE_LENGTH_REGEX = new RegExp(`(?:\\\\((\\\\d*)\\\\))?`);\n\nconst ENTITY_PROPERTY_REGEX = joinRegExps(PROPERTY_NAME_REGEX, OPTIONAL_PROPERTY_MODIFIER_REGEX, /\\s+/, PROPERTY_TYPE_NAME_REGEX, PROPERTY_TYPE_LENGTH_REGEX);\n\nexport const ENTITY_PROPERTY_LINE_REGEX = new RegExp(`^\\\\s*${ENTITY_PROPERTY_REGEX.source}$`);\n\n// Relationship\n\nconst DIRECTION_REGEX = /(<-|->|<->)/;\nconst CARDINALITY_REGEX = /([?1*])?/;\nconst DIRECTION_AND_CARDINALITY_REGEX = joinRegExps(CARDINALITY_REGEX, DIRECTION_REGEX, CARDINALITY_REGEX);\n\nconst ENTITY_AND_ALIAS_REGEX = new RegExp(`(${IDENTIFIER_REGEX.source})(?:\\\\s+(${IDENTIFIER_REGEX.source}))?`);\n\nexport const RELATIONSHIP_LINE_REGEX = new RegExp(`^${ENTITY_AND_ALIAS_REGEX.source}\\\\s*?${DIRECTION_AND_CARDINALITY_REGEX.source}\\\\s*?${ENTITY_AND_ALIAS_REGEX.source}(?:\\\\s+\\\\((${IDENTIFIER_REGEX.source})\\\\))?$`);\n\n// Metadata\n\nconst METADATA_VALUE_REGEX = new RegExp(`(.*)`);\nconst METADATA_ENTRY_REGEX = new RegExp(`-\\\\s*(${IDENTIFIER_REGEX.source})\\\\s*:\\\\s*${METADATA_VALUE_REGEX.source}\\\\s*`);\n\nexport const METADATA_LINE_REGEX = new RegExp(`^\\\\s*${METADATA_ENTRY_REGEX.source}$`);\n","export function escapeRegExp(text: string) {\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nexport function joinRegExps(...regexes: (RegExp | string)[]): RegExp {\n\n    const source = regexes\n        .map((e): string => {\n            if (typeof e === 'string') {\n                return escapeRegExp(e);\n            } else {\n                return e.source\n            }\n        })\n        .join('');\n\n    return new RegExp(source);\n\n}\n","export function capitalize(text: string) {\n    return text[0].toUpperCase() + text.substring(1);\n}\n\nexport function uncapitalize(text: string) {\n    return text[0].toLowerCase() + text.substring(1);\n}\n","import yargs from 'yargs';\nimport fs from 'fs';\nimport {parseEntityRelationshipModel} from './dsl/parser/er-model-parser';\nimport EntityRelationshipModelToCodeConverter from './dsl/generator/entity-relationship-to-code-converter';\nimport MySqlCodeGenerator from 'src/dsl/generator/database/sql/mysql/my-sql-code-generator';\nimport JavaCodeGenerator from './dsl/generator/oop/java/java-code-generator';\nimport {StandardIdNamingStrategies} from '@/dsl/generator/common/id-naming-strategy';\nimport StandardCaseFormats from '@/dsl/generator/common/case-format/StandardCaseFormats'; // [\n\n// [\n// \t'User follower *<->* User followed (a)',\n// \t'User->Shift',\n// ].map(parseRelationshipStatement).forEach(e => console.log(e));\n//\n// [\n// \t'User',\n// \t'Shift',\n// ].map(parseEntityNameStatement).forEach(e => console.log(e));\n//\n// [\n// \t'  username text(50)',\n// \t'  name text(50)',\n// \t'  birthday? date',\n// \t'  registrationDate datetime()',\n// \t'  active bool',\n// ].map(parseEntityPropertyStatement).forEach(e => console.log(e));\n\n// const model = parseEntityRelationshipModel(`\n//\n// User\n// \tusername text(50)\n// \tname text(50)\n// \tbirthday? date\n// \tregistrationDate datetime\n// \tactive bool\n//\n// # comment\n// Shift\n// \tfromTime time\n// \t# other comment :)\n// \ttoTime time\n//\n// Country\n// \tcode text(5)\n// \tname text(100)\n//\n// User ->? Shift\n// User people *-> Country\n//\n// User follower *<->* User follow (Follows)\n//\n// `);\n\n// const model: EntityRelationshipModel = parseEntityRelationshipModel(`\n//\n// User\n// \tusername text(50)\n// \tname text(50)\n// \tbirthday? date\n// \tactive bool\n//\n// Country\n// \tcode text(5)\n// \tname text(100)\n//\n// User *-> Country\n//\n// User ->? Country alternativeCountry\n//\n// Permission\n// \tcode text(30)\n// \tdescription text(200)\n//\n// User *<->* Permission\n//\n// `);\n\nconst args = yargs\n\t\t.option('format', {\n\t\t\talias: 'f',\n\t\t\ttype: 'string',\n\t\t\tdescription: 'Output format (mysql/java)'\n\t\t})\n\t\t.option('output', {\n\t\t\talias: 'o',\n\t\t\ttype: 'string',\n\t\t\tdescription: 'Output file path (console if not specified)'\n\t\t})\n\t\t.help()\n\t\t.alias('help', 'h')\n\t\t.version()\n\t\t.alias('version', 'v')\n\t\t.argv;\n\nconst config = {\n\tinputFile: args._[0],\n\tformat: (args.format ?? 'mysql').toLowerCase(),\n\toutputFile: args.output\n};\n\nconst modelCodeGenerator = ((): EntityRelationshipModelToCodeConverter => {\n\tswitch (config.format) {\n\t\tcase 'mysql':\n\t\t\treturn new MySqlCodeGenerator({\n\t\t\t\tidNamingStrategy: StandardIdNamingStrategies.ENTITY_NAME_PREFIX\n\t\t\t});\n\t\tcase 'java':\n\t\t\treturn new JavaCodeGenerator();\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown format: ${config.format}`);\n\t}\n})();\n\ntype OutputCallback = (text: string) => void;\n\nconst outputCallback = ((): OutputCallback => {\n\n\tconst {outputFile} = config;\n\n\tif (outputFile) {\n\t\treturn text => fs.writeFileSync(outputFile, text + '\\n');\n\t} else {\n\t\treturn text => console.log(text);\n\t}\n\n})();\n\n// const modelCodeGenerator: ModelCodeGenerator = new MySqlCodeGenerator();\n// const modelCodeGenerator: ModelCodeGenerator = new JavaCodeGenerator();\n\nconst inputCode = fs.readFileSync(config.inputFile).toString();\n\nconst model = parseEntityRelationshipModel(inputCode);\nconst outputCode = modelCodeGenerator.generateCode(model);\n\noutputCallback(outputCode);\n\nconsole.log(StandardCaseFormats.LOWER_CAMEL.splitWords('thisIsItSQLException'))\nconsole.log(StandardCaseFormats.UPPER_CAMEL.splitWords('ThisIsItSQLException'))\nconsole.log(StandardCaseFormats.LOWER_UNDERSCORE.splitWords('this_is_it_sql_exception'))\nconsole.log(StandardCaseFormats.UPPER_UNDERSCORE.splitWords('THIS_IS_IT_SQL_EXCEPTION'))\nconsole.log(StandardCaseFormats.CAPITALIZED_UNDERSCORE.splitWords('This_Is_It_Sql_Exception'))\n\nObject.values(StandardCaseFormats).forEach(caseFormat => console.log(caseFormat.joinWords(['thiS', 'is', 'It', 'sql', 'EXCEPTION'])))\n\n// console.log(JSON.stringify(model, null, 4));\n// console.log(modelCodeGenerator.generateCode(model));\n// console.log(JSON.stringify(databaseModelGenerator.generateDatabaseModel(model), null, 4));\n// console.log(JSON.stringify(classModelGenerator.generateClassModel(model), null, 4));\n","module.exports = require(\"assert\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"util\");"],"sourceRoot":""}